#|
 This file is a part of manifolds
 (c) 2023 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.fraf.manifolds)

(defmacro do-faces ((a b c faces &optional result) &body body)
  (let ((i (gensym "I"))
        (f (gensym "F")))
    `(loop with ,f = ,faces
           for ,i from 0 below (length ,f) by 3
           for ,a = (aref ,f (+ 0 ,i))
           for ,b = (aref ,f (+ 1 ,i))
           for ,c = (aref ,f (+ 2 ,i))
           do (progn ,@body)
           finally (return ,result))))

(defun vertex-adjacency-list (faces)
  (check-type faces (simple-array (unsigned-byte 32) (*)))
  (let ((adjacency (make-array (1+ (loop for idx across faces maximize idx)) :initial-element ())))
    (do-faces (a b c faces adjacency)
      (pushnew b (aref adjacency a))
      (pushnew c (aref adjacency a))
      (pushnew a (aref adjacency b))
      (pushnew c (aref adjacency b))
      (pushnew a (aref adjacency c))
      (pushnew b (aref adjacency c)))))

(defun half-edge-list (faces)
  (check-type faces (simple-array (unsigned-byte 32) (*)))
  (let ((edges (make-array (length faces) :element-type 'cons))
        (i 0))
    (flet ((edge (a b)
             (setf (aref edges i) (cons a b))
             (incf i)))
      (do-faces (a b c faces edges)
        (edge a b)
        (edge b c)
        (edge c a)))))

(defun edge-list (faces)
  (check-type faces (simple-array (unsigned-byte 32) (*)))
  (let ((edge-table (make-hash-table :test 'eql))
        (edges (make-array 0 :element-type 'cons :adjustable T :fill-pointer T)))
    (flet ((edge (a b)
             (if (< a b) 
                 (pushnew b (gethash a edge-table))
                 (pushnew a (gethash b edge-table)))))
      (do-faces (a b c faces)
        (edge a b)
        (edge b c)
        (edge c a))
      (loop for a being the hash-keys of edge-table using (hash-value bs)
            do (dolist (b bs)
                 (vector-push-extend (cons a b) edges)))
      edges)))

(defun face-normals (vertices faces &optional (face-normals (make-array (truncate (length faces) 3))))
  (loop for i from 0 below (length faces) by 3
        for j from 0
        for a = (v vertices (aref faces (+ 0 i)))
        for b = (v vertices (aref faces (+ 1 i)))
        for c = (v vertices (aref faces (+ 2 i)))
        do (setf (aref face-normals j) (vc (v- b a) (v- c a))))
  face-normals)

(defun vertex-faces (faces &optional vertex-faces)
  (let ((vertex-faces (or vertex-faces
                          (make-array (loop for vertex across faces maximize vertex)))))
    (dotimes (i (length faces))
      (pushnew (truncate i 3) (aref vertex-faces (aref faces i))))
    (dotimes (i (length faces) vertex-faces)
      (setf (aref vertex-faces i) (nreverse (aref vertex-faces i))))))

(defun ub32 (&rest i)
  (make-array (length i) :element-type '(unsigned-byte 32) :initial-contents i))

(defun 2-manifold-p (faces &optional adjacency)
  (check-type faces (simple-array (unsigned-byte 32) (*)))
  (let ((edge-table (make-hash-table :test 'eql)))
    (flet ((edge-twofaced-p (a b)
             (let ((edge (if (< a b)
                             (+ a (ash b 32))
                             (+ b (ash a 32)))))
               (<= (incf (gethash edge edge-table 0)) 2)))
           (edge-loop-p (adjacency incident)
             (let* ((vertices (aref adjacency incident))
                    (visited (make-hash-table :test 'eql))
                    (stack (list (first vertices))))
               (loop for next = (pop stack)
                     while next
                     do (setf (gethash next visited) T)
                        (dolist (adjacent (aref adjacency next))
                          (when (and (not (gethash adjacent visited))
                                     (member adjacent vertices))
                            (push adjacent stack))))
               (loop for vertex in vertices
                     always (gethash vertex visited)))))
      (and (do-faces (a b c faces T)
             (unless (and (edge-twofaced-p a b)
                          (edge-twofaced-p b c)
                          (edge-twofaced-p c a))
               (return NIL)))
           (loop initially (unless adjacency (setf adjacency (vertex-adjacency-list faces)))
                 for vertex from 0 below (length adjacency)
                 always (edge-loop-p adjacency vertex))))))

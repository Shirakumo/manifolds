;;;; This is a port of the V-HACD implementation by Khaled Mamou et al.
;;;; currently (2023) accessible at https://github.com/kmammou/v-hacd
;;;; With the following differences:
;;;; 
;;;;   - We use libraries instead of bespoke implementations:
;;;;     - 3d-spaces (for the kd-tree)
;;;;     - 3d-vectors
;;;;     - quickhull
;;;;   - The port of parallel code is omitted
;;;;   - We only implement the "flood fill" mode, omitting the surface
;;;;     and raycast implementations. You should instead use the
;;;;     conversion methods in this library to obtain a proper
;;;;     closed 2-manifold if your mesh should be degenerate.
;;;; 
;;;; Any other divergence is purely due to differences in aesthetics and
;;;; conventions between C++ and Lisp. If this port should exhibit bugs
;;;; that are not present in the original code, please file a report.
;;;; 

(in-package #:org.shirakumo.fraf.manifolds)

;;;; Support structures
(defstruct (aabb
            (:constructor make-aabb (&optional min max))
            (:copier NIL)
            (:predicate NIL))
  (min (vec 0 0 0) :type vec3)
  (max (vec 0 0 0) :type vec3))

(defun copy-aabb (a)
  (make-aabb (vcopy (aabb-min a)) (vcopy (aabb-max a))))

(defun aabb-union (a b)
  (make-aabb (vmin (aabb-min a) (aabb-min b))
             (vmax (aabb-max a) (aabb-max b))))

(defun aabb-intersects-p (a b)
  (and (not (or (< (vx3 (aabb-max b)) (vx3 (aabb-min a)))
                (< (vx3 (aabb-max a)) (vx3 (aabb-min b)))))
       (not (or (< (vy3 (aabb-max b)) (vy3 (aabb-min a)))
                (< (vy3 (aabb-max a)) (vy3 (aabb-min b)))))
       (not (or (< (vz3 (aabb-max b)) (vz3 (aabb-min a)))
                (< (vz3 (aabb-max a)) (vz3 (aabb-min b)))))))

(defun aabb-surface-area (a)
  (let ((dx (- (vx3 (aabb-max a)) (vx3 (aabb-min a))))
        (dy (- (vy3 (aabb-max a)) (vy3 (aabb-min a))))
        (dz (- (vz3 (aabb-max a)) (vz3 (aabb-min a)))))
    (* 2.0 (+ (* dx dy) (* dx dz) (* dy dz)))))

(defun aabb-volume (a)
  (let ((dx (- (vx3 (aabb-max a)) (vx3 (aabb-min a))))
        (dy (- (vy3 (aabb-max a)) (vy3 (aabb-min a))))
        (dz (- (vz3 (aabb-max a)) (vz3 (aabb-min a)))))
    (* dx dy dz)))

(defun aabb-inflate (a ratio)
  (let ((inflate (* (v2norm (v- (aabb-min a) (aabb-max a))) 0.5 ratio)))
    (make-aabb (v- (aabb-min a) inflate) (v+ (aabb-max a) inflate))))

(defun aabb-size (a)
  (v- (aabb-max a) (aabb-min a)))

(defun aabb-center (a)
  (nv* (v+ (aabb-max a) (aabb-min a)) 0.5))

(defun aabb-closest-point (a p)
  (vmin (vmax p (aabb-min a)) (aabb-max a)))

(defun aabb-longest-axis (a)
  (let ((x (- (vx (aabb-max a)) (vx (aabb-min a))))
        (y (- (vy (aabb-max a)) (vy (aabb-min a))))
        (z (- (vz (aabb-max a)) (vz (aabb-min a)))))
    (if (< x y)
        (if (< y z) 2 1)
        (if (< x z) 2 0))))

(defun aabb-bounds (vertices &optional (aabb (make-aabb)))
  (let ((min (aabb-min aabb))
        (max (aabb-max aabb)))
    (setf (vx min) (setf (vx max) (aref vertices 0)))
    (setf (vy min) (setf (vy max) (aref vertices 1)))
    (setf (vz min) (setf (vz max) (aref vertices 2)))
    (loop for i from 3 below (length vertices) by 3
          for x = (aref vertices (+ i 0))
          for y = (aref vertices (+ i 1))
          for z = (aref vertices (+ i 2))
          do (setf (vx min) (min (vx min) x))
             (setf (vy min) (min (vy min) y))
             (setf (vz min) (min (vz min) z))
             (setf (vx max) (max (vx max) x))
             (setf (vy max) (max (vy max) y))
             (setf (vz max) (max (vz max) z)))
    aabb))

(defstruct (aabb-node
            (:include aabb)
            (:constructor make-aabb-node)
            (:copier NIL)
            (:predicate NIL))
  (children (make-array 2 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (2)))
  (faces (make-array 0 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (*))))

(defstruct (aabb-tree
            (:constructor %make-aabb-tree (vertices indices faces face-bounds))
            (:copier NIL)
            (:predicate NIL))
  (vertices NIL :type (simple-array single-float (*)))
  (indices NIL :type (simple-array (unsigned-byte 32) (*)))
  (nodes (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (faces NIL :type (simple-array (unsigned-byte 32) (*)))
  (face-bounds NIL :type (simple-array T (*)))
  (depth 0 :type (unsigned-byte 32))
  (inner-nodes 0 :type (unsigned-byte 32))
  (leaf-nodes 0 :type (unsigned-byte 32)))

(defstruct (convex-hull
            (:constructor %make-convex-hull)
            (:include aabb)
            (:copier NIL)
            (:predicate NIL))
  (vertices (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (faces (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (volume 0.0 :type single-float)
  (center (vec 0 0 0) :type vec3))

(defstruct (ch-parameters
            (:copier NIL)
            (:predicate NIL)
            (:conc-name NIL))
  (convex-hulls 64 :type (unsigned-byte 32))
  (resolution 400000 :type (unsigned-byte 32))
  (error-percentage 1.0 :type single-float)
  (max-recursion-depth 10 :type (unsigned-byte 32))
  (shrink-wrap-p T :type boolean)
  (max-vertices-per-convex-hull 64 :type (unsigned-byte 32))
  (minimum-edge-length 2 :type (unsigned-byte 32)))

;;; Skip Googol implementation
;;; Skip kd-tree implementation
;;; Skip Quickhull implementation

(defstruct (plane
            (:include vec3)
            (:constructor plane (&optional 3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3 offset))
            (:copier NIL)
            (:predicate NIL))
  (offset 0.0 :type single-float))

(defun evaluate-plane (plane p)
  (+ (plane-offset plane) (v. plane p)))

(defun make-plane (p0 p1 p2)
  (let ((v (vc (v- p1 p0) (v- p2 p0))))
    (plane (vx3 v) (vy3 v) (vz3 v) (- (v. p0 p0)))))

(deftype voxel () '(unsigned-byte 32))

(defun make-voxel (x y z)
  (logior (ash x 20) (ash y 10) (ash z 0)))

(defun voxel-array (voxel)
  (let ((v (make-array 3 :element-type '(unsigned-byte 10))))
    (setf (aref v 0) (voxel-x voxel))
    (setf (aref v 1) (voxel-y voxel))
    (setf (aref v 2) (voxel-z voxel))
    v))

(defun voxel-x (voxel) (ldb (byte 10 20) voxel))
(defun voxel-y (voxel) (ldb (byte 10 10) voxel))
(defun voxel-z (voxel) (ldb (byte 10  0) voxel))

(defstruct (volume
            (:include aabb)
            (:constructor %make-volume)
            (:copier NIL)
            (:predicate NIL))
  (scale 1.0 :type single-float)
  (dimensions (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (voxels-on-surface 0 :type (unsigned-byte 64))
  (voxels-inside-surface 0 :type (unsigned-byte 64))
  (voxels-outside-surface 0 :type (unsigned-byte 64))
  (data (make-array 0 :element-type '(unsigned-byte 8)) :type (simple-array (unsigned-byte 8) (*)))
  (surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (interior-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel)))

(defstruct (voxel-hull
            (:include aabb)
            (:constructor %make-voxel-hull)
            (:copier NIL)
            (:predicate NIL))
  (axis :x- :type (member :x- :x+ :y- :y+ :z- :z+))
  (voxels (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (voxel-scale 0.0 :type single-float)
  (voxel-scale-half 0.0 :type single-float)
  (voxel-adjust (vec 0 0 0) :type vec3)
  (depth 0 :type (unsigned-byte 32))
  (volume-error 0.0 :type single-float)
  (voxel-volume 0.0 :type single-float)
  (volume 0.0 :type single-float)
  (convex-hull NIL :type (or null convex-hull))
  (surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (new-surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (interior-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (a NIL :type (or null voxel-hull))
  (b NIL :type (or null voxel-hull))
  (m1 (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (m2 (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (aabb-tree NIL :type (or null aabb-tree))
  (voxel-index-map (make-hash-table :test 'eql) :type hash-table)
  (vertices (make-array 0 :element-type 'single-float :adjustable T :fill-pointer T) :type (vector single-float))
  (indices (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T) :type (vector (unsigned-byte 32)))
  (voxel-hull-count 0 :type (unsigned-byte 32))
  (parameters NIL :type ch-parameters))

(defstruct (cost-task
            (:constructor make-cost-task (a b))
            (:copier NIL)
            (:predicate NIL))
  (a NIL :type (or null convex-hull))
  (b NIL :type (or null convex-hull))
  (concavity 0.0 :type single-float))

(defstruct (hull-pair
            (:constructor make-hull-pair (a b concavity))
            (:copier NIL)
            (:predicate NIL))
  (a NIL :type (or null convex-hull))
  (b NIL :type (or null convex-hull))
  (concavity 0.0 :type single-float))

(defstruct (decomposer
            (:constructor %make-decomposer (vertices indices parameters))
            (:copier NIL)
            (:predicate NIL))
  (aabb-tree NIL :type (or null aabb-tree))
  (voxelize NIL :type (or null volume))
  (center (vec3) :type vec3)
  (scale 1.0 :type single-float)
  (recip-scale 1.0 :type single-float)
  (vertices NIL :type (simple-array single-float (*)))
  (indices NIL :type (simple-array (unsigned-byte 32) (*)))
  (overall-hull-volume 0.0 :type single-float)
  (voxel-scale 0.0 :type single-float)
  (parameters NIL :type ch-parameters)
  (hull-pair-queue (priority-queue:make-pqueue #'<= :key-type 'single-float) :type priority-queue::pqueue))

;;;; Additional ops
;;; They implement strange comparators.
(defun v<* (a b)
  (cond ((/= (vx3 a) (vx3 b))
         (< (vx3 a) (vx3 b)))
        ((/= (vy3 a) (vy3 b))
         (< (vy3 a) (vy3 b)))
        (T
         (< (vz3 a) (vz3 b)))))

(defun v>* (a b)
  (cond ((/= (vx3 a) (vx3 b))
         (< (vx3 a) (vx3 b)))
        ((/= (vy3 a) (vy3 b))
         (< (vy3 a) (vy3 b)))
        (T
         (< (vz3 a) (vz3 b)))))

(defun vmaxcoeff (a)
  (let ((x (vx3 a)) (y (vy3 a)) (z (vz3 a)))
    (if (< x y)
        (if (< y z) 
            (values z :z)
            (values y :y))
        (if (< x z)
            (values z :z)
            (values x :x)))))

(defun tetrahedrum-volume (p0 p1 p2 p3)
  (v. (v- p3 p0) (vc (v- p1 p0) (v- p2 p0))))

(defun bit-reversal (v base)
  (let ((x 0)
        (power (truncate (log base 2))))
    (loop do (incf x (ash (logand v 1) power))
             (setf v (ash v -1))
             (decf power)
          while (/= 0 v))
    x))

(defun aabb-ray (aabb start dir)
  (let ((inside-p T)
        (ta (vec3 -1 -1 -1)))
    (macrolet ((test (dim)
                 `(cond ((< (,dim start) (,dim (aabb-min aabb)))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-min aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL))
                        ((< (,dim (aabb-max aabb)) (,dim start))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-max aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL)))))
      (test vx3) (test vy3) (test vz3))
    (if inside-p
        0.0
        (multiple-value-bind (tmax taxis) (vmaxcoeff ta)
          (when (and (<= 0 tmax)
                     (or (eq :x taxis) (and (< (vx (aabb-min aabb)) (vx ta)) (< (vx ta) (vx (aabb-max aabb)))))
                     (or (eq :y taxis) (and (< (vy (aabb-min aabb)) (vy ta)) (< (vy ta) (vy (aabb-max aabb)))))
                     (or (eq :z taxis) (and (< (vz (aabb-min aabb)) (vz ta)) (< (vz ta) (vz (aabb-max aabb))))))
            tmax)))))

(defun ray-triangle (p dir a b c)
  (let* ((ab (v- b a))
         (ac (v- c a))
         (ap (v- p a))
         (n (vc ab ac))
         (d (- (v. dir n)))
         (ood (/ d))
         (tt (* ood (v. ap n))))
    (when (<= 0 tt)
      (let* ((e (v- (vc dir ap)))
             (v (* (v. ac e) ood)))
        (when (<= 0.0 v 1.0)
          (let ((w (- (* (v. ab e) ood))))
            (when (and (<= 0.0 w) (<= (+ v w) 1.0))
              (let ((u (- 1 v w)))
                (values t u v w d n)))))))))

(defmacro with-nesting (&rest things)
  (reduce (lambda (outer inner) `(,@outer ,inner)) things :from-end t))

(defun closest-point-on-triangle* (a b c p)
  (macrolet ((finish (r v w)
               `(let* ((w ,w)
                       (v ,v))
                  (return-from closest-point-on-triangle*
                    (values ,r v w)))))
    (with-nesting
      (let* ((ab (v- b a))
             (ac (v- c a))
             (ap (v- p a))
             (d1 (v. ab ap))
             (d2 (v. ac ap)))
        (when (and (<= d1 0) (<= d2 0))
          (finish a 0 0)))
      (let* ((bp (v- p b))
             (d3 (v. ab bp))
             (d4 (v. ac bp)))
        (when (and (<= 0 d3) (<= d4 d3))
          (finish b 1 0)))
      (let* ((vc (- (* d1 d4) (* d3 d2))))
        (when (and (<= vc 0) (<= 0 d1) (<= d3 0))
          (finish (v+ a (v* ab v)) (/ d1 (- d1 d3)) 0)))
      (let* ((cp (v- p c))
             (d5 (v. ab cp))
             (d6 (v. ac cp)))
        (when (and (<= d6 0) (<= d5 d6))
          (finish 0 1 c)))
      (let* ((vb (- (* d5 d2) (* d1 d6))))
        (when (and (<= vb 0) (<= 0 d2) (<= d6 0))
          (finish (v+ a (v* ac w)) 0 (/ d2 (- d2 d6)))))
      (let* ((va (- (* d3 d6) (* d5 d4))))
        (when (and (<= va 0) (<= 0 (- d4 d3)) (<= 0 (- d5 d6)))
          (finish (v+ b (v* (v- c b) w)) (- 1 w) (/ (- d4 d3) (+ (- d4 d3) (- d5 d6))))))
      (let* ((denom (/ (+ va vb vc))))
        (finish (v+ a (v* ab v) (v* ac w)) (* vb denom) (* vc denom))))))

(defun plane-box-overlap (normal vertex max-box)
  (let ((vmin (vec3)) (vmax (vec3)))
    (macrolet ((test (dim)
                 `(let ((v (,dim vertex)))
                    (if (< 0 (,dim normal))
                        (setf (,dim vmin) (- (- (,dim max-box)) v)
                              (,dim vmax) (- (,dim max-box)))
                        (setf (,dim vmin) (- (,dim max-box) v)
                              (,dim vmax) (- (- (,dim max-box))))))))
      (test vx3)
      (test vy3)
      (test vz3))
    (and (not (< 0 (v. normal vmin)))
         (<= 0 (v. normal vmax)))))

(defun axis-test (a b fa fb v0 v1 v2 v3 box-half-size1 box-half-size2)
  (let* ((p0 (+ (* a v0) (* b v1)))
         (p1 (+ (* a v2) (* b v3)))
         (min (min p0 p1))
         (max (max p0 p1))
         (rad (+ (* fa box-half-size1) (* fb box-half-size2))))
    (not (or (< rad min) (< max (- rad))))))

(defun tri-box-overlap (box-center bsize tri0 tri1 tri2)
  ;; This is SAT.
  (let* ((v0 (v- tri0 box-center))
         (v1 (v- tri1 box-center))
         (v2 (v- tri2 box-center))
         (e0 (v- v1 v0))
         (e1 (v- v2 v1))
         (e2 (v- v0 v2))
         (fe0 (vabs e0))
         (fe1 (vabs e1))
         (fe2 (vabs e2)))
    (when (and (axis-test (vz e0) (- (vy e0)) (vz fe0) (vy fe0) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e0)) (vx e0) (vz fe0) (vx fe0) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e0) (- (vx e0)) (vy fe0) (vx fe0) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize))

               (axis-test (vz e1) (- (vy e1)) (vz fe1) (vy fe1) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e1)) (vx e1) (vz fe1) (vx fe1) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e1) (- (vx e1)) (vy fe1) (vx fe1) (vx v0) (vy v0) (vx v1) (vy v1) (vx bsize) (vz bsize))

               (axis-test (vz e2) (- (vy e2)) (vz fe2) (vy fe2) (vy v0) (vz v0) (vy v1) (vz v1) (vy bsize) (vz bsize))
               (axis-test (- (vz e2)) (vx e2) (vz fe2) (vx fe2) (vx v0) (vz v0) (vx v1) (vz v1) (vx bsize) (vz bsize))
               (axis-test (vy e2) (- (vx e2)) (vy fe2) (vx fe2) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize)))
      (macrolet ((test (dim)
                   `(let ((min (min (,dim v0) (,dim v1) (,dim v2)))
                          (max (max (,dim v0) (,dim v1) (,dim v2))))
                      (not (or (< (,dim bsize) min) (< max (- (,dim bsize))))))))
        (when (and (test vx3) (test vy3) (test vz3))
          (let ((normal (vc e0 e1)))
            (plane-box-overlap normal v0 bsize)))))))

;;; Actual algorithm
(defun make-convex-hull (verts faces)
  (%make-convex-hull :vertices verts :faces faces
                     :center (centroid verts faces)
                     :volume (convex-volume verts faces)))

(defun combine-convex-hulls (a b)
  (multiple-value-bind (verts faces) 
      (org.shirakumo.fraf.quickhull:convex-hull
       (concatenate '(simple-array (unsigned-byte 32))
                    (convex-hull-vertices a) (convex-hull-vertices b)))
    (make-convex-hull verts faces)))

(defun make-aabb-tree (vertices indices)
  (let* ((max-faces-per-leaf 6)
         (num-faces (length indices))
         (faces (make-array num-faces :element-type '(unsigned-byte 32)))
         (face-bounds (make-array num-faces :element-type T))
         (tree (%make-aabb-tree vertices indices faces face-bounds))
         (nodes (aabb-tree-nodes tree))
         (depth 0))
    (dotimes (i num-faces)
      (let ((top (calculate-face-bounds tree i 1)))
        (setf (aref faces i) i)
        (setf (aref face-bounds i) top)))
    (labels ((rec (node start end)
               (let ((num-faces (- end start)))
                 (incf depth)
                 (setf (aabb-tree-depth tree) (max (aabb-tree-depth tree) depth))
                 (calculate-face-bounds tree start end node)
                 (cond ((<= num-faces max-faces-per-leaf)
                        (setf (aabb-node-faces node) (subseq faces start end))
                        (incf (aabb-tree-leaf-nodes tree)))
                       (T
                        (incf (aabb-tree-inner-nodes tree))
                        (let ((left-count (partition-median tree faces start end))
                              (i0 (make-aabb-node))
                              (i1 (make-aabb-node)))
                          (replace (aabb-node-children node) (list i0 i1))
                          (vector-push-extend i0 nodes)
                          (vector-push-extend i1 nodes)
                          (rec i0 start (+ start left-count))
                          (rec i1 (+ start left-count) end))))
                 (decf depth))))
      (rec 0 0 num-faces))
    tree))

(defun trace-ray (tree start dir)
  (let ((tt most-positive-single-float)
        u v w face-sign face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 0))
                             (dist-l (aabb-ray left start dir))
                             (dist-r (aabb-ray right start dir)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef dist-l dist-r))
                        (when (< dist-l tt)
                          (rec left))
                        (when (< dist-r tt)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (tt2 u2 v2 w2 s2) (ray-triangle start dir a b c)
                                 (when (< tt2 tt)
                                   (setf tt tt2 u u2 v v2 w w2 face-sign s2)
                                   (setf face-index (aref (aabb-node-faces node) i)))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (unless (= tt most-positive-single-float)
      (values tt u v w face-sign face-index))))

(defun closest-point-within-distance (tree point max-distance)
  (let ((distance max-distance)
        (sqr-distance (* max-distance max-distance))
        p v w face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 0))
                             (lp (aabb-closest-point left point))
                             (rp (aabb-closest-point right point))
                             (dist-l (vsqrdistance point lp))
                             (dist-r (vsqrdistance point rp)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef lp rp)
                          (rotatef dist-l dist-r))
                        (when (< dist-l sqr-distance)
                          (rec left))
                        (when (< dist-r sqr-distance)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (cp v2 w2) (closest-point-on-triangle* a b c point)
                                 (let ((sqr-distance2 (vsqrdistance cp point)))
                                   (when (< sqr-distance2 sqr-distance)
                                     (setf p cp sqr-distance sqr-distance2 v v2 w w2)
                                     (setf face-index (aref (aabb-node-faces node) i))))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (when p
      (values p distance v w face-index))))

(defun calculate-face-bounds (tree start end &optional (aabb (make-aabb)))
  (flet ((update (p)
           (setf (aabb-min aabb) (vmin (aabb-min aabb) p))
           (setf (aabb-max aabb) (vmax (aabb-max aabb) p))))
    (loop for face from start below end
          for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
          do (update (v (aabb-tree-vertices tree) (+ base-vertex 0)))
             (update (v (aabb-tree-vertices tree) (+ base-vertex 1)))
             (update (v (aabb-tree-vertices tree) (+ base-vertex 2))))
    aabb))

(defun partition-median (tree faces start end)
  (let ((axis (aabb-longest-axis tree))
        (verts (aabb-tree-vertices tree))
        (indices (aabb-tree-indices tree)))
    (labels ((centroid (face)
               (let* ((base-vertex (* 3 (aref indices face)))
                      (a (aref verts (+ axis (* 3 (+ base-vertex 0)))))
                      (b (aref verts (+ axis (* 3 (+ base-vertex 1)))))
                      (c (aref verts (+ axis (* 3 (+ base-vertex 2))))))
                 (/ (+ a b c) 3.0)))
             (compare (lhs rhs)
               (let ((a (centroid lhs))
                     (b (centroid rhs)))
                 (if (= a b)
                     (< lhs rhs)
                     (< a b)))))
      ;; KLUDGE: This SUUUUUCKS
      #-sbcl
      (let ((sub (make-array (- end start)
                             :element-type (array-element-type faces)
                             :displaced-to faces
                             :displaced-index-offset start)))
        (replace faces (sort sub #'compare) :start1 start))
      #+sbcl
      (sb-impl::with-array-data ((vector (the vector faces))
                                 (start start)
                                 (end end)
                                 :check-fill-pointer T)
        (sb-impl::sort-vector vector start end #'compare NIL))
      (truncate (- end start) 2))))

(declaim (inline voxel-value))
(defun voxel-value (v)
  (ecase v
    (0 :undefined)
    (1 :outside-surface-to-walk)
    (2 :outside-surface)
    (3 :inside-surface)
    (4 :on-surface)
    (:undefined 0)
    (:outside-surface-to-walk 1)
    (:outside-surface 2)
    (:inside-surface 3)
    (:on-surface 4)))

(defun voxel (volume x y z)
  (let ((dims (volume-dimensions volume)))
    (aref (volume-data volume)
          (+ x (* (aref dims 0) (+ y (* z (aref dims 1))))))))

(defmacro with-voxel-walk ((i i0 i1) (j j0 j1) (k k0 k1) &body body)
  `(macrolet ((voxel-idx (x y z)
                `(+ ,x (* (aref dims 0) (+ ,y (* (aref dims 1) ,z)))))
              (voxel (x y z)
                `(aref data (voxel-idx ,x ,y ,z))))
     (loop for ,i from ,i0 below ,i1
           do (loop for ,j from ,j0 below ,j1
                    do (loop for ,k from ,k0 below ,k1
                             do ,@body)))))

(defun make-volume (points indices dimensions)
  (let* ((a (expt dimensions 0.33))
         (dim (max 32 (truncate (* a 1.5))))
         (bounds (aabb-bounds points))
         (d (aabb-size bounds))
         (dims (make-array 3 :element-type '(unsigned-byte 32)))
         (r 0.0))
    (cond ((and (<= (vy d) (vx d)) (<= (vz d) (vx d)))
           (replace dims (list dim
                               (+ 2 (truncate (* dim (vy d)) (vx d)))
                               (+ 2 (truncate (* dim (vz d)) (vx d)))))
           (setf r (vx d)))
          ((and (<= (vx d) (vy d)) (<= (vz d) (vx d)))
           (replace dims (list dim
                               (+ 2 (truncate (* dim (vx d)) (vy d)))
                               (+ 2 (truncate (* dim (vz d)) (vy d)))))
           (setf r (vy d)))
          (T
           (replace dims (list dim
                               (+ 2 (truncate (* dim (vx d)) (vz d)))
                               (+ 2 (truncate (* dim (vy d)) (vz d)))))
           (setf r (vz d))))
    (let* ((scale (/ r (1- dim)))
           (inv-scale (/ (1- dim) r))
           (data (make-array (* (aref dims 0) (aref dims 1) (aref dims 2)) 
                             :element-type '(unsigned-byte 8) :initial-element 0))
           (volume (%make-volume :min (aabb-min bounds) :max (aabb-max bounds)
                                 :scale scale :dimensions dims :data data))
           (p (map-into (make-array 3) #'vec3)))
      (loop for base-index from 0 below (length indices) by 3
            for i0 = 0 for j0 = 0 for k0 = 0
            for i1 = 0 for j1 = 0 for k1 = 0
            do (loop for c from 0 below 3
                     for pt = (v points (aref indices (+ base-index c)))
                     do (setf (aref p c) (nv* (v- pt (aabb-min bounds)) inv-scale))
                        (let ((i (truncate (+ 0.5 (vx (aref p c)))))
                              (j (truncate (+ 0.5 (vx (aref p c)))))
                              (k (truncate (+ 0.5 (vx (aref p c))))))
                          (cond ((= 0 c)
                                 (setf i0 i i1 i)
                                 (setf j0 j j1 j)
                                 (setf k0 k k1 k))
                                (T
                                 (setf i0 (min i0 i) i1 (max i1 i))
                                 (setf j0 (min j0 j) j1 (max j1 j))
                                 (setf k0 (min k0 k) k1 (max k1 k))))))
               (when (< 0 i0) (decf i0))
               (when (< 0 j0) (decf j0))
               (when (< 0 k0) (decf k0))
               (when (< i1 (aref dims 0)) (incf i1))
               (when (< j1 (aref dims 1)) (incf j1))
               (when (< k1 (aref dims 2)) (incf k1))
               (with-voxel-walk (i i0 i1) (j j0 j1) (k k0 k1)
                 (when (and (tri-box-overlap (vec i j k) (vec 0.5 0.5 0.5) (aref p 0) (aref p 1) (aref p 2))
                            (= 0 (voxel i j k)))
                   (setf (voxel i j k) (voxel-value :on-surface))
                   (incf (volume-voxels-on-surface volume))
                   (vector-push-extend (make-voxel i j k) (volume-surface-voxels volume)))))
      (mark-outside-surface volume 0 0 0 (aref dims 0) (aref dims 1) 1)
      (mark-outside-surface volume 0 0 (1- (aref dims 2)) (aref dims 0) (aref dims 1) (aref dims 2))
      (mark-outside-surface volume 0 0 0 (aref dims 0) 1 (aref dims 2))
      (mark-outside-surface volume 0 (1- (aref dims 1)) 0 (aref dims 0) (aref dims 1) (aref dims 2))
      (mark-outside-surface volume 0 0 0 1 (aref dims 1) (aref dims 2))
      (mark-outside-surface volume (1- (aref dims 0)) 0 0 (aref dims 0) (aref dims 1) (aref dims 2))
      (fill-outside-surface volume)
      (fill-inside-surface volume))))

(defun mark-outside-surface (volume i0 j0 k0 i1 j1 k1)
  (let ((data (volume-data volume))
        (dims (volume-dimensions volume)))
    (with-voxel-walk (i i0 i1) (j j0 j1) (k k0 k1)
      (when (= 0 (voxel i j k))
        (setf (voxel i j k) (voxel-value :outside-surface-to-walk))))))

(defun walk-forward (data data-i start end stride max-distance)
  (loop for i from start below end
        for count from 0 below max-distance
        while (= 0 (aref data data-i))
        do (setf (aref data data-i) (voxel-value :outside-surface-to-walk))
           (incf data-i stride))
  data-i)

(defun walk-backward (data data-i start end stride max-distance)
  (loop for i downfrom start to end
        for count from 0 below max-distance
        while (= 0 (aref data data-i))
        do (setf (aref data data-i) (voxel-value :outside-surface-to-walk))
           (decf data-i stride))
  data-i)

(defun fill-outside-surface (volume)
  (let* ((voxels-walked 0)
         (i1 (aref (volume-dimensions volume) 0))
         (j1 (aref (volume-dimensions volume) 1))
         (k1 (aref (volume-dimensions volume) 2))
         (walk-distance 64)
         ;; The original code here is bonkers.
         (istride 1)
         (jstride i1)
         (kstride (* i1 j1))
         (dims (volume-dimensions volume))
         (data (volume-data volume)))
    (loop do (setf voxels-walked 0)
             (with-voxel-walk (i 0 i1) (j 0 j1) (k 0 k1)
               (when (= (voxel i j k) (voxel-value :outside-surface-to-walk))
                 (incf voxels-walked)
                 (setf (voxel i j k) (voxel-value :outside-surface))
                 
                 (walk-forward data (+ (voxel-idx i j k) kstride) (1+ k) k1 kstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) kstride) (1- k) 0 kstride walk-distance)

                 (walk-forward data (+ (voxel-idx i j k) jstride) (1+ j) j1 jstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) jstride) (1- j) 0 jstride walk-distance)

                 (walk-forward data (+ (voxel-idx i j k) istride) (1+ i) i1 kstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) istride) (1- i) 0 istride walk-distance)))
             (incf (volume-voxels-outside-surface volume) voxels-walked)
          while (/= 0 voxels-walked))
    volume))

(defun fill-inside-surface (volume)
  (let* ((i1 (aref (volume-dimensions volume) 0))
         (j1 (aref (volume-dimensions volume) 1))
         (k1 (aref (volume-dimensions volume) 2))
         (dims (volume-dimensions volume))
         (data (volume-data volume)))
    (setf (fill-pointer (volume-interior-voxels volume)) 0)
    (with-voxel-walk (i 0 i1) (j 0 j1) (k 0 k1)
      (when (= 0 (voxel i j k))
        (setf (voxel i j k) (voxel-value :inside-surface))
        (vector-push-extend (make-voxel i j k) (volume-interior-voxels volume))
        (incf (volume-voxels-inside-surface volume))))
    volume))

(defun shrink-wrap (verts aabb-tree max-hull-vertex-count distance-threshold shrinkrap-p)
  (when shrinkrap-p
    (loop for j from 0 below (truncate (length verts) 3)
          for p = (v verts j)
          for closest = (closest-point-within-distance aabb-tree p distance-threshold)
          do (when closest
               (setf (aref verts j) closest))))
  (org.shirakumo.fraf.quickhull:convex-hull verts :max-vertex-count max-hull-vertex-count))

(defun make-voxel-hull (parent axis split-loc)
  (let* ((volume (aref (voxel-hull-voxels parent) 0))
         (hull (%make-voxel-hull :min (aabb-min parent)
                                 :max (aabb-max parent)
                                 :axis axis
                                 :voxels (voxel-hull-voxels parent)
                                 :voxel-scale (volume-scale volume)
                                 :voxel-scale-half (* 0.5 (volume-scale volume))
                                 :voxel-adjust (v- (aabb-min volume) (* 0.5 (volume-scale volume)))
                                 :depth (1+ (voxel-hull-depth parent))
                                 :m1 (voxel-hull-m1 parent)
                                 :m2 (voxel-hull-m2 parent)
                                 :parameters (voxel-hull-parameters parent))))
    (case axis
      (:x- (setf (vx (voxel-hull-m2 hull)) split-loc))
      (:x+ (setf (vx (voxel-hull-m1 hull)) (1+ split-loc)))
      (:y- (setf (vy (voxel-hull-m2 hull)) split-loc))
      (:y+ (setf (vy (voxel-hull-m1 hull)) (1+ split-loc)))
      (:z- (setf (vz (voxel-hull-m2 hull)) split-loc))
      (:z+ (setf (vz (voxel-hull-m1 hull)) (1+ split-loc))))
    ;; Copy all intersecting interior voxels
    (loop for v across (voxel-hull-interior-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (if (ecase axis
                     (:x- (= (aref va 0) split-loc))
                     (:x+ (= (aref va 0) (aref (voxel-hull-m1 hull) 0)))
                     (:y- (= (aref va 1) split-loc))
                     (:y+ (= (aref va 1) (aref (voxel-hull-m1 hull) 1)))
                     (:z- (= (aref va 2) split-loc))
                     (:z+ (= (aref va 2) (aref (voxel-hull-m1 hull) 2))))
                   (vector-push-extend v (voxel-hull-surface-voxels hull))
                   (vector-push-extend v (voxel-hull-interior-voxels hull)))))
    ;; Copy all intersecting surface voxels
    (loop for v across (voxel-hull-surface-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (vector-push-extend v (voxel-hull-surface-voxels hull))))
    (loop for v across (voxel-hull-new-surface-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (vector-push-extend v (voxel-hull-new-surface-voxels hull))))
    ;; Recompute the bounding box
    (fill (voxel-hull-m1 hull) #x7FFFFFFF)
    (fill (voxel-hull-m2 hull) 0)
    (loop for v across (voxel-hull-surface-voxels hull) do (min-max-voxel-region hull v))
    (loop for v across (voxel-hull-new-surface-voxels hull) do (min-max-voxel-region hull v))
    (loop for v across (voxel-hull-interior-voxels hull) do (min-max-voxel-region hull v))
    ;; Rebuild
    (build-voxel-mesh hull)
    (build-raycast-mesh hull)
    (compute-convex-hull hull)))

(defun make-voxel-hull* (volume params)
  (let* ((hull (%make-voxel-hull :min (aabb-min volume)
                                 :max (aabb-max volume)
                                 :voxels (vector volume)
                                 :voxel-scale (volume-scale volume)
                                 :voxel-scale-half (* 0.5 (volume-scale volume))
                                 :voxel-adjust (v- (aabb-min volume) (* 0.5 (volume-scale volume)))
                                 :surface-voxels (copy-seq (volume-surface-voxels volume))
                                 :interior-voxels (copy-seq (volume-interior-voxels volume))
                                 :m2 (map '(simple-array (unsigned-byte 32) (3)) #'1- (volume-dimensions volume))
                                 :parameters params)))
    (build-voxel-mesh hull)
    (build-raycast-mesh hull)
    (compute-convex-hull hull)))

(defun min-max-voxel-region (hull v)
  (map-into (voxel-hull-m1 hull) #'min (voxel-hull-m1 hull) (voxel-array v))
  (map-into (voxel-hull-m2 hull) #'max (voxel-hull-m2 hull) (voxel-array v))
  hull)

(defun build-voxel-mesh (hull)
  (loop for v across (voxel-hull-surface-voxels hull)
        do (add-voxel-box hull v))
  (loop for v across (voxel-hull-new-surface-voxels hull)
        do (add-voxel-box hull v)))

(defun build-raycast-mesh (hull)
  (when (/= 0 (length (voxel-hull-indices hull)))
    (setf (voxel-hull-aabb-tree hull) (make-aabb-tree (voxel-hull-vertices hull) (voxel-hull-indices hull))))
  hull)

(defun compute-convex-hull (hull)
  (when (/= 0 (length (voxel-hull-vertices hull)))
    (multiple-value-bind (verts faces) (org.shirakumo.fraf.quickhull:convex-hull (voxel-hull-vertices hull))
      (setf (voxel-hull-convex-hull hull) (make-convex-hull verts faces))))
  (when (voxel-hull-convex-hull hull)
    (setf (voxel-hull-volume hull) (convex-hull-volume (voxel-hull-convex-hull hull))))
  (let ((single-voxel-volume (expt (voxel-hull-voxel-scale hull) 3))
        (voxel-count (+ (length (voxel-hull-interior-voxels hull))
                        (length (voxel-hull-surface-voxels hull))
                        (length (voxel-hull-new-surface-voxels hull)))))
    (setf (voxel-hull-voxel-volume hull) (* voxel-count single-voxel-volume))
    (setf (voxel-hull-volume-error hull) (/ (* (abs (- (voxel-hull-volume hull) (voxel-hull-voxel-volume hull)))
                                               100)
                                            (voxel-hull-voxel-volume hull)))))

(defun voxel-hull-complete-p (hull)
  (or (null (voxel-hull-convex-hull hull))
      (< (voxel-hull-volume-error hull)
         (error-percentage (voxel-hull-parameters hull)))
      (< (max-recursion-depth (voxel-hull-parameters hull)) (voxel-hull-depth hull))
      (every (lambda (m2 m1) (<= (- m2 m1) (minimum-edge-length (voxel-hull-parameters hull))))
             (voxel-hull-m2 hull) (voxel-hull-m1 hull))))

(defun voxel-hull-point (v hull)
  (let ((scale (voxel-hull-voxel-scale hull))
        (bmin (voxel-hull-voxel-adjust hull)))
    (vec (+ (* (voxel-x v) scale) (vx bmin))
         (+ (* (voxel-y v) scale) (vy bmin))
         (+ (* (voxel-z v) scale) (vz bmin)))))

(defun voxel-index (hull v)
  (or (gethash v (voxel-hull-voxel-index-map hull))
      (let ((p (voxel-hull-point v hull))
            (i (hash-table-count (voxel-hull-voxel-index-map hull))))
        (setf (gethash v (voxel-hull-voxel-index-map hull)) i)
        (vector-push-extend (vx p) (voxel-hull-vertices hull))
        (vector-push-extend (vy p) (voxel-hull-vertices hull))
        (vector-push-extend (vz p) (voxel-hull-vertices hull))
        i)))

(defun add-voxel-box (hull v)
  (macrolet ((bmin (dim)
               `(+ 0 (,(intern (format NIL "~a-~a" 'voxel dim)) v)))
             (bmax (dim)
               `(+ 1 (,(intern (format NIL "~a-~a" 'voxel dim)) v))))
    (let ((p0 (vec (bmin x) (bmin y) (bmin z)))
          (p1 (vec (bmax x) (bmin y) (bmin z)))
          (p2 (vec (bmax x) (bmax y) (bmin z)))
          (p3 (vec (bmin x) (bmax y) (bmin z)))
          (p4 (vec (bmin x) (bmin y) (bmax z)))
          (p5 (vec (bmax x) (bmin y) (bmax z)))
          (p6 (vec (bmax x) (bmax y) (bmax z)))
          (p7 (vec (bmin x) (bmax y) (bmax z))))
      (add-triangle hull p2 p1 p0)
      (add-triangle hull p3 p2 p0)

      (add-triangle hull p7 p2 p3)
      (add-triangle hull p7 p6 p2)

      (add-triangle hull p5 p1 p2)
      (add-triangle hull p5 p2 p6)

      (add-triangle hull p5 p4 p1)
      (add-triangle hull p4 p0 p1)

      (add-triangle hull p4 p6 p7)
      (add-triangle hull p4 p5 p6)

      (add-triangle hull p4 p7 p0)
      (add-triangle hull p7 p3 p0))))

(defun add-triangle (hull p1 p2 p3)
  (vector-push-extend (voxel-index hull p1) (voxel-hull-indices hull))
  (vector-push-extend (voxel-index hull p2) (voxel-hull-indices hull))
  (vector-push-extend (voxel-index hull p3) (voxel-hull-indices hull)))

(defun compute-split-plane (hull)
  (let ((d (map 'vector #'- (voxel-hull-m2 hull) (voxel-hull-m1 hull))))
    (cond ((and (<= (aref d 1) (aref d 0)) (<= (aref d 2) (aref d 0)))
           (values :x
                   (/ (+ 1 (aref (voxel-hull-m2 hull) 0) (aref (voxel-hull-m1 hull) 0)) 2)))
          ((and (<= (aref d 0) (aref d 1)) (<= (aref d 2) (aref d 1)))
           (values :y
                   (/ (+ 1 (aref (voxel-hull-m2 hull) 1) (aref (voxel-hull-m1 hull) 1)) 2)))
          (T
           (values :z
                   (/ (+ 1 (aref (voxel-hull-m2 hull) 2) (aref (voxel-hull-m1 hull) 2)) 2))))))

(defun raycast (hull p1 p2)
  (let* ((from (voxel-hull-point hull p1))
         (dir (nvunit (v- (voxel-hull-point hull p2) from))))
    (or (trace-ray (voxel-hull-aabb-tree hull) from dir) 0.0)))

;; Omit find-concavity

(defun perform-plane-split (hull)
  (unless (voxel-hull-complete-p hull)
    (multiple-value-bind (axis split-location) (compute-split-plane hull)
      (ecase axis
        (:x
         (setf (voxel-hull-a hull) (make-voxel-hull hull :x- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :x+ split-location)))
        (:y
         (setf (voxel-hull-a hull) (make-voxel-hull hull :y- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :y+ split-location)))
        (:z
         (setf (voxel-hull-a hull) (make-voxel-hull hull :z- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :z+ split-location))))))
  hull)

(defun reduce-convex-hull (decomposer ch &key (max-vertices (max-vertices-per-convex-hull (decomposer-parameters decomposer)))
                                              (shrink-wrap-p (shrink-wrap-p (decomposer-parameters decomposer))))
  (multiple-value-bind (verts faces) (shrink-wrap (convex-hull-vertices ch)
                                                  (decomposer-aabb-tree decomposer)
                                                  max-vertices (* 4 (decomposer-voxel-scale decomposer))
                                                  shrink-wrap-p)
    (make-convex-hull verts faces)))

(defun compute-concavity (volume-separate volume-combined volume-mesh)
  (/ (abs (- volume-separate volume-combined)) volume-mesh))

(defun perform-task (decomposer task)
  (let* ((a (cost-task-a task))
         (b (cost-task-b task))
         (va (convex-hull-volume a))
         (vb (convex-hull-volume b))
         (combined (combine-convex-hulls a b))
         (combined-volume (convex-hull-volume combined)))
    (setf (cost-task-concavity task) (compute-concavity (+ va vb) combined-volume (decomposer-overall-hull-volume decomposer)))))

(defun fast-cost (decomposer task)
  (let ((a (cost-task-a task))
        (b (cost-task-b task)))
    (unless (aabb-intersects-p a b)
      (let ((concavity (compute-concavity (+ (convex-hull-volume a) (convex-hull-volume a))
                                          (aabb-volume (aabb-union a b))
                                          (decomposer-overall-hull-volume decomposer))))
        (priority-queue:pqueue-push (make-hull-pair a b concavity) concavity
                                    (decomposer-hull-pair-queue decomposer))))))

(defun add-cost (decomposer task)
  (priority-queue:pqueue-push (make-hull-pair (cost-task-a task) (cost-task-b task) (cost-task-concavity task))
                              (cost-task-concavity task)
                              (decomposer-hull-pair-queue decomposer)))

(defun scale-convex-hull (decomposer hull)
  (let ((verts (convex-hull-vertices hull))
        (faces (convex-hull-faces hull))
        (scale (decomposer-scale decomposer))
        (center (decomposer-center decomposer)))
    (loop for v from 0 below (length verts) by 3
          do (setf (aref verts (+ 0 v)) (+ (vx center) (* scale (aref verts (+ 0 v)))))
             (setf (aref verts (+ 1 v)) (+ (vy center) (* scale (aref verts (+ 1 v)))))
             (setf (aref verts (+ 2 v)) (+ (vz center) (* scale (aref verts (+ 2 v))))))
    (setf (convex-hull-volume hull) (convex-volume verts faces))
    (setf (convex-hull-center hull) (centroid verts faces))
    hull))

(defun %decompose (decomposer)
  ;; Prepare the necessary data
  (let* ((params (decomposer-parameters decomposer))
         (pending (make-array 0 :adjustable T :fill-pointer T))
         (voxel-hulls (make-array 0 :adjustable T :fill-pointer T))
         (hulls (make-array 0 :adjustable T :fill-pointer T))
         (max-convex-hull-fragments 100000)
         (bounds (aabb-bounds (decomposer-vertices decomposer)))
         (center (aabb-center bounds)))
    (setf (decomposer-center decomposer) center)
    (setf (decomposer-scale decomposer) (vmaxcoeff (v- (aabb-max bounds) (aabb-min bounds))))
    (setf (decomposer-recip-scale decomposer) (if (= 0 (decomposer-scale decomposer))
                                                  0.0
                                                  (decomposer-scale decomposer)))
    ;; IMPL:
    ;; ???? Don't understand this fuckery with VertexIndex and how it relates to a kd-tree
    ;;
    (setf (decomposer-aabb-tree decomposer) (make-aabb-tree (decomposer-vertices decomposer)
                                                            (decomposer-indices decomposer)))
    (setf (decomposer-voxelize decomposer) (make-volume (decomposer-vertices decomposer)
                                                        (decomposer-indices decomposer)
                                                        (resolution params)))
    (setf (decomposer-voxel-scale decomposer) (volume-scale (decomposer-voxelize decomposer)))
    (let ((vh (make-voxel-hull* (decomposer-voxelize decomposer) params)))
      (when (voxel-hull-convex-hull vh)
        (setf (decomposer-overall-hull-volume decomposer)
              (convex-hull-volume (voxel-hull-convex-hull vh))))
      (vector-push-extend vh pending)
      ;; Split hulls as much as possible
      (loop while (< 0 (length pending))
            do (let ((count (+ (length pending) (length voxel-hulls)))
                     (old (copy-seq pending)))
                 (loop for hull across old
                       do (unless (or (voxel-hull-complete-p hull) (< max-convex-hull-fragments count))
                            (perform-plane-split hull)))
                 (loop for hull across old
                       do (cond ((or (voxel-hull-complete-p hull) (< max-convex-hull-fragments count))
                                 (when (voxel-hull-convex-hull hull)
                                   (vector-push-extend hull voxel-hulls)))
                                (T
                                 (when (voxel-hull-a hull)
                                   (vector-push-extend (voxel-hull-a hull) pending))
                                 (when (voxel-hull-b hull)
                                   (vector-push-extend (voxel-hull-b hull) pending))))))))
    ;; Build the hull ID map
    (loop for hull across voxel-hulls
          ;; ?? it does a copy here, but why?
          for ch = (voxel-hull-convex-hull hull)
          for id = (length hulls)
          do (setf (convex-hull-id ch) id)
             (vector-push-extend ch hulls))
    ;; Merge convex hulls down as much as needed
    (let ((hull-count (length hulls)))
      (when (< (convex-hulls params) hull-count)
        (let ((tasks (make-array 0 :adjustable T :fill-pointer T)))
          ;; Compute the costs and init our priority queue
          (loop for i from 1 below hull-count
                for ch-a = (aref hulls i)
                do (loop for j from 0 below i
                         for ch-b = (aref hulls j)
                         for task = (make-cost-task ch-a ch-b)
                         do (unless (fast-cost decomposer task)
                              (vector-push-extend task tasks))))
          (loop for task across tasks
                do (perform-task decomposer task)
                   (add-cost decomposer task)))
        ;; Actually merge convex hulls now
        (loop until (or (priority-queue:pqueue-empty-p (decomposer-hull-pair-queue decomposer))
                        (<= (convex-hulls params) (length hulls)))
              do (let* ((pair (priority-queue:pqueue-pop (decomposer-hull-pair-queue decomposer)))
                        (ch-a (hull-pair-a pair))
                        (ch-b (hull-pair-b pair)))
                   (when (and ch-a ch-b)
                     (let ((combined (combine-convex-hulls ch-a ch-b))
                           (tasks (make-array 0 :adjustable T :fill-pointer T)))
                       (setf (convex-hull-id combined) (length hulls))
                       (loop for hull across hulls
                             for task = (make-cost-task combined hull)
                             do (unless (fast-cost decomposer task)
                                  (vector-push-extend task tasks)))
                       (vector-push-extend combined hulls)
                       (loop for task across tasks
                             do (perform-task decomposer task))
                       (loop for task across tasks
                             do (add-cost decomposer task))))))))
    ;; Finalize by reducing hulls if necessary and scaling them
    (loop for i from 0 below (length hulls)
          for hull = (aref hulls i)
          do (when (or (< (max-vertices-per-convex-hull params)
                          (truncate (length (convex-hull-vertices hull)) 3))
                       (shrink-wrap-p params))
               (setf (aref hulls i) (setf hull (reduce-convex-hull decomposer hull))))
             (scale-convex-hull decomposer hull))
    hulls))

(defun make-decomposer (verts faces &rest args)
  (%make-decomposer verts faces (apply #'make-ch-parameters args)))

(defun decompose (verts faces &rest args &key convex-hulls
                                              resolution
                                              error-percentage
                                              max-recursion-depth
                                              shrink-wrap-p
                                              max-vertices-per-convex-hull
                                              minimum-edge-length)
  (declare (ignore convex-hulls resolution error-percentage max-recursion-depth
                   shrink-wrap-p max-vertices-per-convex-hull minimum-edge-length))
  (%decompose (apply #'make-decomposer verts faces args)))

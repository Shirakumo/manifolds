;;;; This is a port of the V-HACD implementation by Khaled Mamou et al.
;;;; currently (2023) accessible at https://github.com/kmammou/v-hacd
;;;; With the following differences:
;;;; 
;;;;   - We use libraries instead of bespoke implementations:
;;;;     - 3d-spaces (for the kd-tree)
;;;;     - 3d-vectors
;;;;     - quickhull
;;;;   - The port of parallel code is omitted
;;;;   - We only implement the "flood fill" mode, omitting the surface
;;;;     and raycast implementations. You should instead use the
;;;;     conversion methods in this library to obtain a proper
;;;;     closed 2-manifold if your mesh should be degenerate.
;;;; 
;;;; Any other divergence is purely due to differences in aesthetics and
;;;; conventions between C++ and Lisp. If this port should exhibit bugs
;;;; that are not present in the original code, please file a report.
;;;; 

(in-package #:org.shirakumo.fraf.manifolds)

;;;; Support structures
(defstruct (aabb
            (:constructor make-aabb (&optional min max))
            (:copier NIL)
            (:predicate NIL))
  (min (vec 0 0 0) :type vec3)
  (max (vec 0 0 0) :type vec3))

(defun aabb-union (a b)
  (make-aabb (vmin (aabb-min a) (aabb-min b))
             (vmax (aabb-max a) (aabb-max b))))

(defun aabb-intersects-p (a b)
  (and (not (or (< (vx3 (aabb-max b)) (vx3 (aabb-min a)))
                (< (vx3 (aabb-max a)) (vx3 (aabb-min b)))))
       (not (or (< (vy3 (aabb-max b)) (vy3 (aabb-min a)))
                (< (vy3 (aabb-max a)) (vy3 (aabb-min b)))))
       (not (or (< (vz3 (aabb-max b)) (vz3 (aabb-min a)))
                (< (vz3 (aabb-max a)) (vz3 (aabb-min b)))))))

(defun aabb-surface-area (a)
  (let ((dx (- (vx3 (aabb-max a)) (vx3 (aabb-min a))))
        (dy (- (vy3 (aabb-max a)) (vy3 (aabb-min a))))
        (dz (- (vz3 (aabb-max a)) (vz3 (aabb-min a)))))
    (* 2.0 (+ (* dx dy) (* dx dz) (* dy dz)))))

(defun aabb-volume (a)
  (let ((dx (- (vx3 (aabb-max a)) (vx3 (aabb-min a))))
        (dy (- (vy3 (aabb-max a)) (vy3 (aabb-min a))))
        (dz (- (vz3 (aabb-max a)) (vz3 (aabb-min a)))))
    (* dx dy dz)))

(defun aabb-inflate (a ratio)
  (let ((inflate (* (v2norm (v- (aabb-min a) (aabb-max a))) 0.5 ratio)))
    (make-aabb (v- (aabb-min a) inflate) (v+ (aabb-max a) inflate))))

(defun aabb-size (a)
  (v- (aabb-max a) (aabb-min a)))

(defun aabb-center (a)
  (nv* (v+ (aabb-max a) (aabb-min a)) 0.5))

(defun aabb-closest-point (a p)
  (vmin (vmax p (aabb-min a)) (aabb-max a)))

(defun aabb-longest-axis (a)
  (let ((x (- (vx (aabb-max a)) (vx (aabb-min a))))
        (y (- (vy (aabb-max a)) (vy (aabb-min a))))
        (z (- (vz (aabb-max a)) (vz (aabb-min a)))))
    (if (< x y)
        (if (< y z) 2 1)
        (if (< x z) 2 0))))

(defstruct (aabb-node
            (:include aabb)
            (:constructor make-aabb-node)
            (:copier NIL)
            (:predicate NIL))
  (children (make-array 2 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (2)))
  (faces (make-array 0 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (*))))

(defstruct (aabb-tree
            (:constructor %make-aabb-tree (vertices indices faces face-bounds))
            (:copier NIL)
            (:predicate NIL))
  (vertices NIL :type (simple-array single-float (*)))
  (indices NIL :type (simple-array (unsigned-byte 32) (*)))
  (nodes (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (faces NIL :type (simple-array (unsigned-byte 32) (*)))
  (face-bounds NIL :type (simple-array T (*)))
  (depth 0 :type (unsigned-byte 32))
  (inner-nodes 0 :type (unsigned-byte 32))
  (leaf-nodes 0 :type (unsigned-byte 32)))

(defstruct (convex-hull
            (:constructor %make-convex-hull ())
            (:include aabb)
            (:copier NIL)
            (:predicate NIL))
  (id 0 :type (unsigned-byte 32))
  (points (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (triangles (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (volume 0d0 :type double-float)
  (center (vec 0 0 0) :type vec3)
  ;; Private
  (list () :type list)
  (aabb-p0 (vec 0 0 0) :type vec3)
  (aabb-p1 (vec 0 0 0) :type vec3)
  (diagonal 0.0 :type single-float))

(defstruct (ch-parameters
            (:copier NIL)
            (:predicate NIL))
  (convex-hulls 64 :type (unsigned-byte 32))
  (resolution 400000 :type (unsigned-byte 32))
  (error-percentage 1.0 :type single-float)
  (max-recursion-depth 10 :type (unsigned-byte 32))
  (shrink-wrap T :type boolean)
  (max-vertices-per-convex-hull 64 :type (unsigned-byte 32))
  (minimum-edge-length 2 :type (unsigned-byte 32)))

;;; Skip Googol implementation
;;; Skip kd-tree implementation
;;; Skip Quickhull implementation

(defstruct (plane
            (:include vec3)
            (:constructor plane (&optional 3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3 offset))
            (:copier NIL)
            (:predicate NIL))
  (offset 0.0 :type single-float))

(defun evaluate-plane (plane p)
  (+ (plane-offset plane) (v. plane p)))

(defun make-plane (p0 p1 p2)
  (let ((v (vc (v- p1 p0) (v- p2 p0))))
    (plane (vx3 v) (vy3 v) (vz3 v) (- (v. p0 p0)))))

(defstruct (hull-face
            (:constructor %hull-face ())
            (:copier NIL)
            (:predicate NIL))
  (index (make-array 3) :type (simple-array (unsigned-byte 32) (3)))
  (twin (make-array 3) :type (simple-array T (3)))
  (mark NIL :type boolean))

(defun hull-face (p0 p1 p2)
  (let ((face (%hull-face)))
    (replace (hull-face-index face) (list p0 p1 p2))
    face))

(defun evaluate-hull-face (face vertices point)
  (let ((p0 (v vertices (aref (hull-face-index face) 0)))
        (p1 (v vertices (aref (hull-face-index face) 1)))
        (p2 (v vertices (aref (hull-face-index face) 2))))
    (multiple-value-bind (det error) (determinant3x3 (v- p2 p0) (v- p1 p0) (v- point p0))
      (let* ((precision (/ 1.0d0 (ash 1 24)))
             (errbound (* error precision)))
        (if (< errbound (abs det))
            det
            (error "Not implemented"))))))

(defun hull-face-plane (face vertices)
  (let ((a (v vertices (aref (hull-face-index face) 0)))
        (b (v vertices (aref (hull-face-index face) 1)))
        (c (v vertices (aref (hull-face-index face) 2)))
        (plane (plane)))
    (v<- plane (vc (v- b a) (v- c a)))
    (setf (plane-offset plane) (- (v. plane a)))
    (let ((mag2 (v. plane plane)))
      (when (< 1.0e-16 mag2)
        (let ((invmag (/ (sqrt mag2))))
          (nv* plane invmag)
          (setf (plane-offset plane) (* (plane-offset plane) invmag)))
        plane))))

(defstruct (hull-vertex
            (:include vec3)
            (:constructor hull-vertex (&optional 3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3))
            (:copier NIL)
            (:predicate NIL))
  (mark NIL :type boolean))

(deftype voxel () '(unsigned-byte 32))

(defun make-voxel (x y z)
  (logior (ash x 20) (ash y 10) (ash z 0)))

(defun voxel-x (voxel) (ldb (byte 10 20) voxel))
(defun voxel-y (voxel) (ldb (byte 10 10) voxel))
(defun voxel-z (voxel) (ldb (byte 10  0) voxel))

(defstruct (normal-map
            (:constructor %make-normal-map ())
            (:copier NIL)
            (:predicate NIL))
  (normals (map-into (make-array 128) #'vec3) :type (simple-array vec3 (128)))
  (count 128 :type (unsigned-byte 8)))

(defun tessellate-triangle (map level p0 p1 p2 count)
  (cond ((< 0 level)
         (let ((p01 (nvunit (v+ p0 p1)))
               (p12 (nvunit (v+ p1 p2)))
               (p20 (nvunit (v+ p2 p0))))
           (setf count (tessellate-triangle map (1- level) p0 p01 p20 count))
           (setf count (tessellate-triangle map (1- level) p1 p12 p01 count))
           (setf count (tessellate-triangle map (1- level) p2 p20 p12 count))
           (setf count (tessellate-triangle map (1- level) p01 p12 p20 count))))
        (T
         (let ((plane (make-plane p0 p1 p2)))
           (nvunit plane)
           (setf (plane-offset plane) 0.0)
           (let ((index (bit-reversal count (length (normal-map-normals map)))))
             (setf (aref (normal-map-normals map) index) plane)
             (incf count))))))

(defun make-normal-map ()
  (let ((map (%make-normal-map)))
    (let ((p0 (vec +1 0 0)) (p1 (vec -1 0 0))
          (p2 (vec 0 +1 0)) (p3 (vec 0 -1 0))
          (p4 (vec 0 0 +1)) (p5 (vec 0 0 -1)))
      (let ((count 0) (subdivisions 2))
        (setf count (tessellate-triangle map subdivisions p4 p0 p2 count))
        (setf count (tessellate-triangle map subdivisions p0 p5 p2 count))
        (setf count (tessellate-triangle map subdivisions p5 p1 p2 count))
        (setf count (tessellate-triangle map subdivisions p1 p4 p2 count))
        (setf count (tessellate-triangle map subdivisions p0 p4 p3 count))
        (setf count (tessellate-triangle map subdivisions p5 p0 p3 count))
        (setf count (tessellate-triangle map subdivisions p1 p5 p3 count))
        (setf count (tessellate-triangle map subdivisions p4 p1 p3 count))))))

(defstruct (volume
            (:include aabb)
            (:constructor %make-volume (data surface-voxels interior-voxels)))
  (scale 1.0 :type single-float)
  (dimensions (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (voxels-on-surface 0 :type (unsigned-byte 64))
  (voxels-inside-surface 0 :type (unsigned-byte 64))
  (voxels-outside-surface 0 :type (unsigned-byte 64))
  (data NIL :type (simple-array (unsigned-byte 8) (*)))
  (surface-voxels NIL :type (simple-array voxel (*)))
  (interior-voxels NIL :type (simple-array voxel (*))))

;;;; Additional ops
;;; They implement strange comparators.
(defun v<* (a b)
  (cond ((/= (vx3 a) (vx3 b))
         (< (vx3 a) (vx3 b)))
        ((/= (vy3 a) (vy3 b))
         (< (vy3 a) (vy3 b)))
        (T
         (< (vz3 a) (vz3 b)))))

(defun v>* (a b)
  (cond ((/= (vx3 a) (vx3 b))
         (< (vx3 a) (vx3 b)))
        ((/= (vy3 a) (vy3 b))
         (< (vy3 a) (vy3 b)))
        (T
         (< (vz3 a) (vz3 b)))))

(defun vmaxcoeff (a)
  (let ((x (vx3 a)) (y (vy3 a)) (z (vz3 a)))
    (if (< x y)
        (if (< y z) 
            (values z :z)
            (values y :y))
        (if (< x z)
            (values z :z)
            (values x :x)))))

(defun determinant3x3 (a b c)
  (let ((a01xa12 (* (vy3 a) (vz3 b)))
        (a02xa11 (* (vz3 a) (vy3 b)))
        (a00xa12 (* (vx3 a) (vz3 b)))
        (a02xa10 (* (vz3 a) (vx3 b)))
        (a00xa11 (* (vx3 a) (vy3 b)))
        (a01xa10 (* (vy3 a) (vx3 b))))
    (values (+ (* (- a01xa12 a02xa11) (vx3 c))
               (- (* (- a00xa12 a02xa10) (vy3 c)))
               (* (- a00xa11 a01xa10) (vz3 c)))
            (+ (+ (abs a01xa12) (* (abs a02xa11) (abs (vX3 c))))
               (+ (abs a00xa12) (* (abs a02xa10) (abs (vY3 c))))
               (+ (abs a00xa11) (* (abs a01xa10) (abs (vZ3 c))))))))

(defun mesh-volume (vertices faces)
  (let ((volume 0d0))
    (do-faces (a b c faces (abs (* volume (/ 1 6))))
      (incf volume (determinant3x3 (v vertices a) (v vertices b) (v vertices c))))))

(defun tetrahedrum-volume (p0 p1 p2 p3)
  (v. (v- p3 p0) (vc (v- p1 p0) (v- p2 p0))))

(defun bit-reversal (v base)
  (let ((x 0)
        (power (truncate (log base 2))))
    (loop do (incf x (ash (logand v 1) power))
             (setf v (ash v -1))
             (decf power)
          while (/= 0 v))
    x))

(defun aabb-ray (aabb start dir)
  (let ((inside-p T)
        (ta (vec3 -1 -1 -1)))
    (macrolet ((test (dim)
                 `(cond ((< (,dim start) (,dim (aabb-min aabb)))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-min aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL))
                        ((< (,dim (aabb-max aabb)) (,dim start))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-max aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL)))))
      (test vx3) (test vy3) (test vz3))
    (if inside-p
        0.0
        (multiple-value-bind (tmax taxis) (vmaxcoeff ta)
          (when (and (<= 0 tmax)
                     (or (eq :x taxis) (and (< (vx (aabb-min aabb)) (vx hit)) (< (vx hit) (vx (aabb-max aabb)))))
                     (or (eq :y taxis) (and (< (vy (aabb-min aabb)) (vy hit)) (< (vy hit) (vy (aabb-max aabb)))))
                     (or (eq :z taxis) (and (< (vz (aabb-min aabb)) (vz hit)) (< (vz hit) (vz (aabb-max aabb))))))
            tmax)))))

(defun ray-triangle (p dir a b c)
  (let* ((ab (v- b a))
         (ac (v- c a))
         (n (vc ab ac))
         (d (- (v. dir n)))
         (ood (/ d))
         (tt (* ood (v. ap n))))
    (when (<= 0 tt)
      (let ((e (v- (vc dir ap)))
            (v (* (v. ac e) ood)))
        (when (<= 0.0 v 1.0)
          (let ((w (- (* (v. ab e) ood))))
            (when (and (<= 0.0 w) (<= (+ v w) 1.0))
              (let ((u (- 1 v w)))
                (values t u v w d n)))))))))

(defmacro with-nesting (&rest things)
  (reduce (lambda (outer inner) `(,@outer ,inner)) things :from-end t))

(defun closest-point-on-triangle* (a b c p)
  (macrolet ((finish (r v w)
               `(let* ((w ,w)
                       (v ,v))
                  (return-from closest-point-on-triangle*
                    (values ,r v w)))))
    (with-nesting
      (let* ((ab (v- b a))
             (ac (v- c a))
             (ap (v- p a))
             (d1 (v. ab ap))
             (d2 (v. ac ap)))
        (when (and (<= d1 0) (<= d2 0))
          (finish a 0 0)))
      (let* ((bp (v- p b))
             (d3 (v. ab bp))
             (d4 (v. ac bp)))
        (when (and (<= 0 d3) (<= d4 d3))
          (finish b 1 0)))
      (let* ((vc (- (* d1 d4) (* d3 d2))))
        (when (and (<= vc 0) (<= 0 d1) (<= d3 0))
          (finish (v+ a (v* ab v)) (/ d1 (- d1 d3)) 0)))
      (let* ((cp (v- p c))
             (d5 (v. ab cp))
             (d6 (v. ac cp)))
        (when (and (<= d6 0) (<= d5 d6))
          (finish 0 1 c)))
      (let* ((vb (- (* d5 d2) (* d1 d6))))
        (when (and (<= vb 0) (<= 0 d2) (<= d6 0))
          (finish (v+ a (v* ac w)) 0 (/ d2 (- d2 d6)))))
      (let* ((va (- (* d3 d6) (* d5 d4))))
        (when (and (<= va 0) (<= 0 (- d4 d3)) (<= 0 (- d5 d6)))
          (finish (v+ b (v* (v- c b) w)) (- 1 w) (/ (- d4 d3) (+ (- d4 d3) (- d5 d6))))))
      (let* ((denom (/ (+ va vb vc))))
        (finish (v+ a (v* ab v) (v* ac w)) (* vb denom) (* vc denom))))))

(defun plane-box-overlap (normal vertex max-box)
  (let ((vmin (vec3)) (vmax (vec3)))
    (macrolet ((test (dim)
                 `(let ((v (,dim vertex)))
                    (if (< 0 (,dim normal))
                        (setf (,dim vmin) (- (- (,dim max-box)) v)
                              (,dim vmax) (- (,dim max-box)))
                        (setf (,dim vmin) (- (,dim max-box) v)
                              (,dim vmax) (- (- (,dim max-box))))))))
      (test vx3)
      (test vy3)
      (test vz3))
    (and (not (< 0 (v. normal vmin)))
         (<= 0 (v. normal vmax)))))

(defun axis-test (a b fa fb v0 v1 v2 v3 box-half-size1 box-half-size2)
  (let* ((p0 (+ (* a v0) (* b v1)))
         (p1 (+ (* a v2) (* b v3)))
         (min (min p0 p1))
         (max (max p0 p1))
         (rad (+ (* fa box-half-size1) (* fb box-half-size2))))
    (not (or (< rad min) (< max (- rad))))))

(defun tri-box-overlap (box-center bsize tri0 tri1 tri2)
  ;; This is SAT.
  (let* ((v0 (v- tri0 box-center))
         (v1 (v- tri1 box-center))
         (v2 (v- tri2 box-center))
         (e0 (v- v1 v0))
         (e1 (v- v2 v1))
         (e2 (v- v0 v2))
         (fe0 (vabs e0))
         (fe1 (vabs e1))
         (fe2 (vabs e2)))
    (when (and (axis-test (vz e0) (- (vy e0)) (vz fe0) (vy fe0) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e0)) (vx e0) (vz fe0) (vx fe0) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e0) (- (vx e0)) (vy fe0) (vx fe0) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize))

               (axis-test (vz e1) (- (vy e1)) (vz fe1) (vy fe1) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e1)) (vx e1) (vz fe1) (vx fe1) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e1) (- (vx e1)) (vy fe1) (vx fe1) (vx v0) (vy v0) (vx v1) (vy v1) (vx bsize) (vz bsize))

               (axis-test (vz e2) (- (vy e2)) (vz fe2) (vy fe2) (vy v0) (vz v0) (vy v1) (vz v1) (vy bsize) (vz bsize))
               (axis-test (- (vz e2)) (vx e2) (vz fe2) (vx fe2) (vx v0) (vz v0) (vx v1) (vz v1) (vx bsize) (vz bsize))
               (axis-test (vy e2) (- (vx e2)) (vy fe2) (vx fe2) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize)))
      (macrolet ((test (dim)
                   `(let ((min (min (,dim v0) (,dim v1) (,dim v2)))
                          (max (max (,dim v0) (,dim v1) (,dim v2))))
                      (not (or (< (,dim bsize) min) (< max (- (,dim bsize))))))))
        (when (and (test vx3) (test vy3) (test vz3))
          (let ((normal (vc e0 e1)))
            (plane-box-overlap normal v0 bsize)))))))

;;; Actual algorithm

(defun make-convex-hull (vertex-cloud dist-to-l max-vertex-count)
  (let* ((hull (%make-convex-hull))
         ;;(tree-count (* 2 (max 4 (truncate (length vertex-cloud) (* 3 (ash 8 -1))))))
         (points (make-array (truncate (length vertex-cloud) 3))))
    (loop for i from 0 below (length points)
          for j from 0 by 3
          do (setf (aref points i) (hull-vertex (aref vertex-cloud (+ j 0))
                                                (aref vertex-cloud (+ j 1))
                                                (aref vertex-cloud (+ j 2)))))
    (let ((count (init-vertex-array hull points)))
      (when (<= 4 (length (convex-hull-points hull)))
        (calculate-convex-hull-3d hull points count dist-to-l max-vertex-count))
      hull)))

(defun unique-points (points)
  (setf points (sort points #'v<))
  (let ((index-count 0))
    (loop for i from 1 below (length points)
          do (loop while (< i (length points))
                   do (when (v/= (aref points index-count) (aref points i))
                        (incf index-count)
                        (setf (aref points index-count) (aref points i))
                        (loop-finish))))
    (adjust-array points (1+ index-count))))

(defun build-tree (points)
  (let ((points (unique-points points)))
    (build-tree-recurse NIL points 0 (length points) 0)))

(defun build-tree-recurse (parent points start end base)
  (let (tree
        (count (- end start))
        (min-p (vec +1.0e15 +1.0e15 +1.0e15))
        (max-p (vec -1.0e15 -1.0e15 -1.0e15)))
    (cond ((<= count 8)
           (let ((clump (make-aabb-node :count count)))
             (dotimes (i count)
               (setf (aref (aabb-node-indices clump) i) (+ i start base))
               (setf min-p (vmin min-p (aref points (+ i start))))
               (setf max-p (vmax max-p (aref points (+ i start)))))
             (setf tree clump)))
          (T
           (let ((median (vec3))
                 (varian (vec3)))
             (loop for i from start below end
                   for p = (aref points i)
                   do (setf min-p (vmin min-p p))
                      (setf max-p (vmax max-p p))
                      (nv+ median p)
                      (nv+ varian (v* p p)))
             (nv* varian count)
             (nv- varian (v* median median))
             (let ((dim #'vx3) (max-varian -1.0e10))
               (dolist (d (list #'vx3 #'vy3 #'vz3))
                 (when (< max-varian (funcall d varian))
                   (setf dim d)
                   (setf max-varian (funcall d varian))))
               (let ((test (funcall dim (v/ median count)))
                     (i0 start) (i1 (1- end)))
                 (loop do (loop while (and (<= i0 i1) (not (< test (funcall dim (aref points i0)))))
                                do (incf i0))
                          (loop while (and (<= i0 i1) (not (< (funcall dim (aref points i1)) test)))
                                do (decf i1))
                          (when (< i0 i1)
                            (rotatef (aref points i0) (aref points i1))
                            (incf i0) (decf i1))
                       while (<= i0 i1))
                 (when (or (= start i0) (<= (1- end) i0)) (setf i0 (+ start (truncate count 2))))
                 (let ((tree (make-aabb-node)))
                   (setf (aabb-node-left tree) (build-tree-recurse tree points start i0 base))
                   (setf (aabb-node-right tree) (build-tree-recurse tree points i0 end (+ (- i0 start) base)))))))))
    (setf (aabb-node-parent tree) parent)
    (setf (aabb-node-min tree) (v- min-p (vec3 1.0e-3 1.0e-3 1.0e-3)))
    (setf (aabb-node-max tree) (v+ max-p (vec3 1.0e-3 1.0e-3 1.0e-3)))
    tree))

(defun support-vertex (tree-node points dir-plane &optional remove-entry-p)
  (let ((aabb-projection (make-array 64 :element-type 'single-float))
        (stack-pool (make-array 64))
        (dir (vcopy dir-plane))
        (stack 0)
        (max-projection -1.0e20)
        (ix (< 0 (vx3 dir-plane)))
        (iy (< 0 (vy3 dir-plane)))
        (iz (< 0 (vz3 dir-plane)))
        index)
    (flet ((support-point (node)
             (vec (vx (if ix (aabb-node-max node) (aabb-node-min node)))
                  (vy (if iy (aabb-node-max node) (aabb-node-min node)))
                  (vz (if iz (aabb-node-max node) (aabb-node-min node)))))
           (push-stack (distance node)
             (setf (aref aabb-projection stack) distance)
             (setf (aref stack-pool stack) node)
             (incf stack)))
      (push-stack 1.0e20 tree-node)
      (loop while (< 0 stack)
            do (decf stack)
               (let ((box-support-value (aref aabb-projection stack))
                     (me (aref stack-pool stack)))
                 (when (< max-projection box-support-value)
                   (cond ((and (aabb-node-left me) (aabb-node-right me))
                          (let ((left-support-distance (v. (support-point (aabb-node-left me)) dir))
                                (right-support-distance (v. (support-point (aabb-node-right me)) dir)))
                            (cond ((<= left-support-distance right-support-distance)
                                   (push-stack left-support-distance (aabb-node-left me))
                                   (push-stack right-support-distance (aabb-node-right me)))
                                  (T
                                   (push-stack right-support-distance (aabb-node-right me))
                                   (push-stack left-support-distance (aabb-node-left me))))))
                         (T
                          (loop for i from 0 below (length (aabb-node-indices me))
                                for p = (aref points (aref (aabb-node-indices me) i))
                                do (cond ((not (hull-vertex-mark p))
                                          (let ((dist (v. p dir)))
                                            (when (< max-projection dist)
                                              (setf max-projection dist)
                                              (setf index (aref (aabb-node-indices me) i)))))
                                         (remove-entry-p
                                          (decf (aabb-node-count me))
                                          (setf (aref (aabb-node-indices me) i) (aref (aabb-node-indices me) (aabb-node-count me)))
                                          (decf i))))
                          (when (= 0 (aabb-node-count me))
                            (when (aabb-node-parent me)
                              (let* ((parent (aabb-node-parent me))
                                     (grandparent (aabb-node-parent parent))
                                     (sibling (if (eq me (aabb-node-left parent))
                                                  (aabb-node-right parent)
                                                  (aabb-node-left parent))))
                                (cond (grandparent
                                       (setf (aabb-node-parent sibling) grandparent)
                                       (if (eq parent (aabb-node-right grandparent))
                                           (setf (aabb-node-right grandparent) sibling)
                                           (setf (aabb-node-left grandparent) sibling)))
                                      (T
                                       (setf (aabb-node-parent sibling) NIL)
                                       (setf tree-node sibling))))))))))))
    index))

(defun init-vertex-array (hull points)
  (let* ((tree (build-tree points))
         (count (length points))
         (normal-map (make-normal-map))
         (m-points (convex-hull-points hull))
         (diag (vdistance (aabb-node-max tree) (aabb-node-min tree))))
    (adjust-array m-points count)
    (v<- (convex-hull-aabb-p0 hull) (aabb-node-min tree))
    (v<- (convex-hull-aabb-p1 hull) (aabb-node-max tree))
    (setf (convex-hull-diagonal hull) diag)
    (let ((index0 (support-vertex tree points (aref (normal-map-normals normal-map) 0)))
          (valid-tetrahedrum-p NIL)
          (e1 (vec3)) (e2 (vec3)) (e3 (vec3)) (normal (vec3)))
      (setf (aref m-points 0) (aref points index0))
      ;; FIXME: dunno if this property transferring here is OK.
      (setf (hull-vertex-mark (aref points index0)) T)
      (loop for normal across (normal-map-normals normal-map)
            for index = (support-vertex tree points normal)
            do (v<- e1 (aref points index))
               (nv- e1 (aref m-points 0))
               (when (< (* diag diag 1.0e-4) (vsqrlength e1))
                 (setf (aref m-points 1) (aref points index))
                 (setf (hull-vertex-mark (aref points index)) T)
                 (setf valid-tetrahedrum-p T)
                 (return)))
      (assert valid-tetrahedrum-p)
      (setf valid-tetrahedrum-p NIL)
      (loop for i from 2 below (normal-map-count normal-map)
            for index = (support-vertex tree points (aref (normal-map-normals normal-map) i))
            do (v<- e2 (aref points index))
               (nv- e2 (aref m-points 0))
               (v<- normal (vc e1 e2))
               (when (< (* diag diag 1.0e-4) (vlength normal))
                 (setf (aref m-points 2) (aref points index))
                 (setf (hull-vertex-mark (aref points index)) T)
                 (setf valid-tetrahedrum-p T)
                 (return)))
      ;; Find the largest possible tetrahedrum
      (assert valid-tetrahedrum-p)
      (setf valid-tetrahedrum-p NIL)
      (setf index0 (support-vertex tree points normal))
      (v<- e3 (aref points index0))
      (nv- e3 (aref m-points 0))
      (when (< (* diag diag 1.0e-6) (abs (v. normal e3)))
        (setf (aref m-points 3) (aref points index0))
        (setf (hull-vertex-mark (aref points index0)) T)
        (setf valid-tetrahedrum-p T))
      (unless valid-tetrahedrum-p
        (setf index0 (support-vertex tree points (v- normal)))
        (v<- e3 (aref points index0))
        (nv- e3 (aref m-points 0))
        (when (< (* diag diag 1.0e-6) (abs (v. normal e3)))
          (setf (aref m-points 3) (aref points index0))
          (setf (hull-vertex-mark (aref points index0)) T)
          (setf valid-tetrahedrum-p T)))
      (unless valid-tetrahedrum-p
        (loop for i from 3 below (normal-map-count normal-map)
              for index = (support-vertex tree points (aref (normal-map-normals normal-map) i))
              do (v<- e3 (aref points index))
                 (nv- e3 (aref m-points 0))
                 (when (< (* diag diag 1.0e-6) (abs (v. normal e3)))
                   (setf (aref m-points 3) (aref points index))
                   (setf (hull-vertex-mark (aref points index)) T)
                   (setf valid-tetrahedrum-p T)
                   (return))))
      (assert valid-tetrahedrum-p)
      (adjust-array m-points 4)
      (when (< 0 (tetrahedrum-volume (aref m-points 0) (aref m-points 1) (aref m-points 2) (aref m-points 3)))
        (rotatef (aref m-points 2) (aref m-points 3)))
      count)))

(defun hull-add-face (hull i0 i1 i2)
  (let ((face (hull-face i0 i1 i2)))
    (push face (convex-hull-list hull))
    face))

(defmacro push-back (el list)
  ;; FIXME: I know this isn't quite right.
  (let ((nv (gensym "NEW-VALUE"))
        (v (gensym "VALUE")))
    `(let ((,nv (list ,el))
           (,v ,list))
       (cond (,v
              (setf (cdr (last ,v)) ,nv)
              ,v)
             (T
              (setf ,list ,nv))))))

(defun calculate-convex-hull-3d (hull tree points count dist-to-l max-vertex-count)
  (setf dist-to-l (* (convex-hull-diagonal hull) (abs dist-to-l)))
  (let* ((f0 (hull-add-face hull 0 1 2))
         (f1 (hull-add-face hull 0 2 3))
         (f2 (hull-add-face hull 2 1 3))
         (f3 (hull-add-face hull 1 0 3))
         (m-points (convex-hull-points hull))
         (boundary (list f0 f1 f2 f3))
         (current-index 4)
         (stack ()) (cone-list ()) (delete-list ()))
    (replace (hull-face-twin f0) (list f3 f2 f1))
    (replace (hull-face-twin f1) (list f0 f2 f3))
    (replace (hull-face-twin f2) (list f0 f3 f1))
    (replace (hull-face-twin f3) (list f0 f1 f2))
    (adjust-array (convex-hull-points hull) count)
    (decf count 4)
    (decf max-vertex-count 4)
    (loop for face = (car (last boundary))
          for index = 0
          for dist = 0.0
          for p = (vec3)
          while (and boundary (< 0 count) (< 0 max-vertex-count))
          do (let ((plane (hull-face-plane face m-points)))
               (when plane
                 (setf index (support-vertex tree points plane))
                 (setf p (aref points index))
                 (setf dist (evaluate-plane plane p)))
               (cond ((and plane (<= dist-to-l dist) (< (evaluate-hull-face face m-points p) 0))
                      (push face stack)
                      (setf delete-list ())
                      (loop for face = (pop stack)
                            while face
                            do (when (and (not (hull-face-mark face)) (< (evaluate-hull-face face m-points p) 0))
                                 (push face delete-list)
                                 (setf (hull-face-mark face) T)
                                 (loop for twin across (hull-face-twin face)
                                       do (unless (hull-face-mark twin)
                                            (push twin stack)))))
                      (setf (aref m-points current-index) (aref points index))
                      (setf (hull-vertex-mark (aref points index)) T)
                      (setf cone-list ())
                      (dolist (face delete-list)
                        (loop for twin across (hull-face-twin face)
                              for j from 0
                              do (unless (hull-face-mark twin)
                                   (let ((new (hull-add-face hull current-index 
                                                             (aref (hull-face-index face) j)
                                                             (aref (hull-face-index face) (mod (1+ j) 2)))))
                                     (push new boundary)
                                     (setf (aref (hull-face-twin new) 1) twin)
                                     (loop for i from 0 below (length (hull-face-twin twin))
                                           do (when (eq face (aref (hull-face-twin twin) i))
                                                (setf (aref (hull-face-twin twin) i) new)))
                                     (push-back new cone-list)))))
                      (loop for (face-a . rest) on cone-list
                            do (loop for face-b in rest
                                     do (when (eq (aref (hull-face-index face-a) 2) (aref (hull-face-index face-b) 1))
                                          (setf (aref (hull-face-twin face-a) 2) face-b)
                                          (setf (aref (hull-face-twin face-b) 0) face-a)
                                          (return)))
                               (loop for face-b in rest
                                     do (when (eq (aref (hull-face-index face-a) 1) (aref (hull-face-index face-b) 2))
                                          (setf (aref (hull-face-twin face-a) 0) face-b)
                                          (setf (aref (hull-face-twin face-b) 2) face-a)
                                          (return))))
                      (loop for face in delete-list
                            do (setf boundary (delete face boundary))
                               (setf (convex-hull-list hull) (delete face (convex-hull-list hull))))
                      (decf max-vertex-count)
                      (incf current-index)
                      (decf count))
                     (T
                      (setf boundary (delete face boundary))))))
    (setf (fill-pointer m-points) current-index)))

(defun make-aabb-tree (vertices indices)
  (let* ((max-faces-per-leaf 6)
         (num-faces (length indices))
         (faces (make-array num-faces :element-type '(unsigned-byte 32)))
         (face-bounds (make-array num-faces :element-type T))
         (tree (%make-aabb-tree vertices indices faces face-bounds))
         (nodes (aabb-tree-nodes tree))
         (depth 0))
    (dotimes (i num-faces)
      (let ((top (calculate-face-bounds tree i 1)))
        (setf (aref faces i) i)
        (setf (aref face-bounds i) top)))
    (labels ((rec (node start end)
               (let ((num-faces (- end start)))
                 (incf depth)
                 (setf (aabb-tree-depth tree) (max (aabb-tree-depth tree) depth))
                 (calculate-face-bounds tree start end node)
                 (cond ((<= num-faces max-faces-per-leaf)
                        (setf (aabb-node-faces node) (subseq faces start end))
                        (incf (aabb-tree-leaf-nodes tree)))
                       (T
                        (incf (aabb-tree-inner-nodes tree))
                        (let ((left-count (partition-median tree faces start end))
                              (i0 (make-aabb-node))
                              (i1 (make-aabb-node)))
                          (replace (aabb-node-children node) (list i0 i1))
                          (vector-push-extend i0 nodes)
                          (vector-push-extend i1 nodes)
                          (rec i0 start (+ start left-count))
                          (rec i1 (+ start left-count) end))))
                 (decf depth))))
      (rec 0 0 num-faces))))

(defun trace-ray (tree start dir)
  (let ((tt most-positive-single-float)
        u v w face-sign face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 0))
                             (dist-l (aabb-ray left start dir))
                             (dist-r (aabb-ray right start dir)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef dist-l dist-r))
                        (when (< dist-l tt)
                          (rec left))
                        (when (< dist-r tt)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (tt2 u2 v2 w2 s2) (ray-triangle start dir a b c)
                                 (when (< tt2 tt)
                                   (setf tt tt2 u u2 v v2 w w2 face-sign s2)
                                   (setf face-index (aref (aabb-node-faces node) i)))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (unless (= tt most-positive-single-float)
      (values tt u v w face-sign face-index))))

(defun closest-point-within-distance (tree point max-distance)
  (let ((distance max-distance)
        (sqr-distance (* max-distance max-distance))
        p v w face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 0))
                             (lp (aabb-closest-point left point))
                             (rp (aabb-closest-point right point))
                             (dist-l (vsqrdistance point lp))
                             (dist-r (vsqrdistance point rp)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef lp rp)
                          (rotatef dist-l dist-r))
                        (when (< dist-l sqr-distance)
                          (rec left))
                        (when (< dist-r sqr-distance)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (cp v2 w2) (closest-point-on-triangle* a b c point)
                                 (let ((sqr-distance2 (vsqrdistance cp point)))
                                   (when (< sqr-distance2 sqr-distance)
                                     (setf p cp sqr-distance sqr-distance2 v v2 w w2)
                                     (setf face-index (aref (aabb-node-faces node) i))))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (when p
      (values p distance v w face-index))))

(defun calculate-face-bounds (tree start end &optional (aabb (make-aabb)))
  (flet ((update (p)
           (setf (aabb-min aabb) (vmin (aabb-min aabb) p))
           (setf (aabb-max aabb) (vmax (aabb-max aabb) p))))
    (loop for face from start below end
          for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
          do (update (v (aabb-tree-vertices tree) (+ base-vertex 0)))
             (update (v (aabb-tree-vertices tree) (+ base-vertex 1)))
             (update (v (aabb-tree-vertices tree) (+ base-vertex 2))))
    aabb))

(defun partition-median (tree faces start end)
  (let ((axis (aabb-longest-axis tree))
        (verts (aabb-tree-vertices tree))
        (indices (aabb-tree-indices tree)))
    (labels ((centroid (face)
               (let* ((base-vertex (* 3 (aref indices face)))
                      (a (aref verts (+ axis (* 3 (+ base-vertex 0)))))
                      (b (aref verts (+ axis (* 3 (+ base-vertex 1)))))
                      (c (aref verts (+ axis (* 3 (+ base-vertex 2))))))
                 (/ (+ a b c) 3.0)))
             (compare (lhs rhs)
               (let ((a (centroid lhs))
                     (b (centroid rhs)))
                 (if (= a b)
                     (< lhs rhs)
                     (< a b)))))
      ;; KLUDGE: This SUUUUUCKS
      #-sbcl
      (let ((sub (make-array (- end start)
                             :element-type (array-element-type faces)
                             :displaced-to faces
                             :displaced-index-offset start)))
        (replace faces (sort sub #'compare) :start1 start))
      #+sbcl
      (sb-impl::with-array-data ((vector (the vector faces))
                                 (start start)
                                 (end end)
                                 :check-fill-pointer t)
        (sb-impl::sort-vector vector start end #'compare NIL))
      (truncate (- end start) 2))))



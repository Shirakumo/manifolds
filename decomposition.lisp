;;;; This is a port of the V-HACD implementation by Khaled Mamou et al.
;;;; currently (2023) accessible at https://github.com/kmammou/v-hacd
;;;; With the following differences:
;;;; 
;;;;   - We use libraries instead of bespoke implementations:
;;;;     - 3d-spaces (for the kd-tree)
;;;;     - 3d-vectors
;;;;     - quickhull
;;;;   - The port of parallel code is omitted
;;;;   - We only implement the "flood fill" mode, omitting the surface
;;;;     and raycast implementations. You should instead use the
;;;;     conversion methods in this library to obtain a proper
;;;;     closed 2-manifold if your mesh should be degenerate.
;;;; 
;;;; Any other divergence is purely due to differences in aesthetics and
;;;; conventions between C++ and Lisp. If this port should exhibit bugs
;;;; that are not present in the original code, please file a report.
;;;; 

(in-package #:org.shirakumo.fraf.manifolds)

;;;; Support structures
(defstruct (aabb-node
            (:include aabb)
            (:constructor make-aabb-node)
            (:copier NIL)
            (:predicate NIL))
  (children (make-array 2 :initial-element NIL) :type (simple-array T (2)))
  (faces (make-array 0 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (*))))

(defmethod print-object ((node aabb-node) stream)
  (print-unreadable-object (node stream :type T)
    (format stream "~a ~a " (aabb-min node) (aabb-max node))
    (if (= 0 (length (aabb-node-faces node)))
        (format stream "INTERIOR")
        (format stream "LEAF"))))

(defstruct (aabb-tree
            (:constructor %make-aabb-tree (vertices indices faces))
            (:copier NIL)
            (:predicate NIL))
  (vertices NIL :type (simple-array double-float (*)))
  (indices NIL :type (simple-array (unsigned-byte 32) (*)))
  (faces NIL :type (simple-array (unsigned-byte 32) (*)))
  (nodes (make-array 0 :adjustable T :fill-pointer T) :type (array T (*)))
  (depth 0 :type (unsigned-byte 32))
  (inner-nodes 0 :type (unsigned-byte 32))
  (leaf-nodes 0 :type (unsigned-byte 32)))

(defmethod print-object ((tree aabb-tree) stream)
  (print-unreadable-object (tree stream :type T)
    (format stream "depth ~d, ~d inner ~d leaf nodes"
            (aabb-tree-depth tree) (aabb-tree-inner-nodes tree) (aabb-tree-leaf-nodes tree))))

(defstruct (convex-hull
            (:constructor %make-convex-hull)
            (:include aabb)
            (:copier NIL)
            (:predicate NIL))
  (vertices (make-array 0 :element-type 'double-float) :type (simple-array double-float (*)))
  (faces (make-array 0 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (*)))
  (volume 0.0d0 :type double-float)
  (center (vec 0 0 0) :type vec3))

(defmethod print-object ((hull convex-hull) stream)
  (print-unreadable-object (hull stream :type T)
    (format stream "~a ~a " (aabb-min hull) (aabb-max hull))
    (format stream "~d verts ~d faces ~f volume"
            (length (convex-hull-vertices hull))
            (length (convex-hull-faces hull))
            (convex-hull-volume hull))))

(defstruct (vertex-index
            (:include vec3)
            (:constructor make-vertex-index (3d-vectors::%vx3 3d-vectors::%vy3 3d-vectors::%vz3 index))
            (:copier NIL)
            (:predicate NIL))
  (index 0 :type (unsigned-byte 32)))

(defmethod print-object ((index vertex-index) stream)
  (print-unreadable-object (index stream :type T)
    (format stream "~d ~f ~f ~f"
            (vertex-index-index index) (vx index) (vy index) (vz index))))

(defmethod org.shirakumo.fraf.trial.space:location ((v vertex-index)) v)
(defmethod org.shirakumo.fraf.trial.space:bsize ((v vertex-index)) #.(vec 0 0 0))

(deftype voxel () '(unsigned-byte 32))

(defun make-voxel (x y z)
  (logior (ash x 20) (ash y 10) (ash z 0)))

(defun voxel-array (voxel)
  (let ((v (make-array 3 :element-type '(unsigned-byte 10))))
    (setf (aref v 0) (voxel-x voxel))
    (setf (aref v 1) (voxel-y voxel))
    (setf (aref v 2) (voxel-z voxel))
    v))

(defun voxel-x (voxel) (ldb (byte 10 20) voxel))
(defun voxel-y (voxel) (ldb (byte 10 10) voxel))
(defun voxel-z (voxel) (ldb (byte 10  0) voxel))

(defstruct (volume
            (:include aabb)
            (:constructor %make-volume)
            (:copier NIL)
            (:predicate NIL))
  (scale 1.0d0 :type double-float)
  (dimensions (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (voxels-on-surface 0 :type (unsigned-byte 64))
  (voxels-inside-surface 0 :type (unsigned-byte 64))
  (voxels-outside-surface 0 :type (unsigned-byte 64))
  (data (make-array 0 :element-type '(unsigned-byte 8)) :type (simple-array (unsigned-byte 8) (*)))
  (surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (interior-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel)))

(defmethod print-object ((volume volume) stream)
  (print-unreadable-object (volume stream :type T)
    (format stream "~a ~a " (aabb-min volume) (aabb-max volume))
    (format stream "~a ~d on surface ~d inside ~d outside"
            (volume-dimensions volume)
            (volume-voxels-on-surface volume)
            (volume-voxels-inside-surface volume)
            (volume-voxels-outside-surface volume))))

(defstruct (voxel-hull
            (:include aabb)
            (:constructor %make-voxel-hull)
            (:copier NIL)
            (:predicate NIL))
  (axis :x- :type (member :x- :x+ :y- :y+ :z- :z+))
  (voxels (make-array 0 :adjustable T :fill-pointer T) :type vector)
  (voxel-scale 0.0d0 :type double-float)
  (voxel-adjust (vec 0 0 0) :type vec3)
  (depth 0 :type (unsigned-byte 32))
  (volume-error 0.0d0 :type double-float)
  (voxel-volume 0.0d0 :type double-float)
  (volume 0.0d0 :type double-float)
  (convex-hull NIL :type (or null convex-hull))
  (surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (new-surface-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (interior-voxels (make-array 0 :element-type 'voxel :adjustable T :fill-pointer T) :type (vector voxel))
  (a NIL :type (or null voxel-hull))
  (b NIL :type (or null voxel-hull))
  (m1 (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (m2 (make-array 3 :element-type '(unsigned-byte 32)) :type (simple-array (unsigned-byte 32) (3)))
  (aabb-tree NIL :type (or null aabb-tree))
  (voxel-index-map (make-hash-table :test 'eql) :type hash-table)
  (vertices (make-array 0 :element-type 'double-float :adjustable T :fill-pointer T) :type (vector double-float))
  (indices (make-array 0 :element-type '(unsigned-byte 32) :adjustable T :fill-pointer T) :type (vector (unsigned-byte 32)))
  (voxel-hull-count 0 :type (unsigned-byte 32))
  (decomposer NIL :type T))

(defmethod print-object ((hull voxel-hull) stream)
  (print-unreadable-object (hull stream :type T)
    (format stream "~a ~a " (aabb-min hull) (aabb-max hull))
    (format stream "~a at ~d, ~d hulls, ~d voxels"
            (voxel-hull-axis hull)
            (voxel-hull-depth hull)
            (voxel-hull-voxel-hull-count hull)
            (+ (length (voxel-hull-surface-voxels hull))
               (length (voxel-hull-new-surface-voxels hull))
               (length (voxel-hull-interior-voxels hull))))))

(defstruct (cost-task
            (:constructor make-cost-task (a b))
            (:copier NIL)
            (:predicate NIL))
  (a NIL :type (or null convex-hull))
  (b NIL :type (or null convex-hull))
  (concavity 0.0d0 :type double-float))

(defstruct (hull-pair
            (:constructor make-hull-pair (a b concavity))
            (:copier NIL)
            (:predicate NIL))
  (a NIL :type (or null convex-hull))
  (b NIL :type (or null convex-hull))
  (concavity 0.0d0 :type double-float))

(defstruct (decomposer
            (:constructor make-decomposer)
            (:copier NIL)
            (:predicate NIL))
  (aabb-tree NIL :type (or null aabb-tree))
  (voxelize NIL :type (or null volume))
  (center (vec3) :type vec3)
  (scale 1.0d0 :type double-float)
  (recip-scale 1.0d0 :type double-float)
  (overall-hull-volume 0.0d0 :type double-float)
  (voxel-scale 0.0d0 :type double-float)
  (hull-pair-queue (priority-queue:make-pqueue #'<= :key-type 'double-float) :type priority-queue::pqueue)
  ;; Parameters
  (convex-hulls 64 :type (unsigned-byte 32))
  (resolution 400000 :type (unsigned-byte 32))
  (error-percentage 1.0d0 :type double-float)
  (max-recursion-depth 10 :type (unsigned-byte 32))
  (shrink-wrap-p T :type boolean)
  (max-vertices-per-convex-hull 64 :type (unsigned-byte 32))
  (max-convex-hull-fragments 100000 :type (unsigned-byte 32))
  (minimum-edge-length 2 :type (unsigned-byte 32)))

(defmethod print-object ((decomposer decomposer) stream)
  (print-unreadable-object (decomposer stream :type T)))

;;;; Additional ops
(defun vmaxcoeff (a)
  (let ((x (vx3 a)) (y (vy3 a)) (z (vz3 a)))
    (if (< x y)
        (if (< y z) 
            (values z :z)
            (values y :y))
        (if (< x z)
            (values z :z)
            (values x :x)))))

(defun aabb-ray (aabb start dir)
  (let ((inside-p T)
        (ta (vec3 -1 -1 -1)))
    (macrolet ((test (dim)
                 `(cond ((< (,dim start) (,dim (aabb-min aabb)))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-min aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL))
                        ((< (,dim (aabb-max aabb)) (,dim start))
                         (when (/= 0 (,dim dir))
                           (setf (,dim ta) (/ (- (,dim (aabb-max aabb)) (,dim start)) (,dim dir))))
                         (setf inside-p NIL)))))
      (test vx3) (test vy3) (test vz3))
    (if inside-p
        0.0d0
        (multiple-value-bind (tmax taxis) (vmaxcoeff ta)
          (when (and (<= 0 tmax)
                     (or (eq :x taxis) (and (< (vx (aabb-min aabb)) (vx ta)) (< (vx ta) (vx (aabb-max aabb)))))
                     (or (eq :y taxis) (and (< (vy (aabb-min aabb)) (vy ta)) (< (vy ta) (vy (aabb-max aabb)))))
                     (or (eq :z taxis) (and (< (vz (aabb-min aabb)) (vz ta)) (< (vz ta) (vz (aabb-max aabb))))))
            tmax)))))

(defun ray-triangle (p dir a b c)
  (let* ((ab (v- b a))
         (ac (v- c a))
         (ap (v- p a))
         (n (vc ab ac))
         (d (- (v. dir n)))
         (ood (/ d))
         (tt (* ood (v. ap n))))
    (when (<= 0 tt)
      (let* ((e (v- (vc dir ap)))
             (v (* (v. ac e) ood)))
        (when (<= 0 v 1)
          (let ((w (- (* (v. ab e) ood))))
            (when (and (<= 0 w) (<= (+ v w) 1))
              (let ((u (- 1 v w)))
                (values t u v w d n)))))))))

(defmacro with-nesting (&rest things)
  (reduce (lambda (outer inner) `(,@outer ,inner)) things :from-end t))

(defun closest-point-on-triangle* (a b c p)
  (macrolet ((finish (r v w)
               `(let* ((w ,w)
                       (v ,v))
                  (return-from closest-point-on-triangle*
                    (values ,r v w)))))
    (with-nesting
      (let* ((ab (v- b a))
             (ac (v- c a))
             (ap (v- p a))
             (d1 (v. ab ap))
             (d2 (v. ac ap)))
        (when (and (<= d1 0) (<= d2 0))
          (finish a 0 0)))
      (let* ((bp (v- p b))
             (d3 (v. ab bp))
             (d4 (v. ac bp)))
        (when (and (<= 0 d3) (<= d4 d3))
          (finish b 1 0)))
      (let* ((vc (- (* d1 d4) (* d3 d2))))
        (when (and (<= vc 0) (<= 0 d1) (<= d3 0))
          (finish (v+ a (v* ab v)) (/ d1 (- d1 d3)) 0)))
      (let* ((cp (v- p c))
             (d5 (v. ab cp))
             (d6 (v. ac cp)))
        (when (and (<= d6 0) (<= d5 d6))
          (finish 0 1 c)))
      (let* ((vb (- (* d5 d2) (* d1 d6))))
        (when (and (<= vb 0) (<= 0 d2) (<= d6 0))
          (finish (v+ a (v* ac w)) 0 (/ d2 (- d2 d6)))))
      (let* ((va (- (* d3 d6) (* d5 d4))))
        (when (and (<= va 0) (<= 0 (- d4 d3)) (<= 0 (- d5 d6)))
          (finish (v+ b (v* (v- c b) w)) (- 1 w) (/ (- d4 d3) (+ (- d4 d3) (- d5 d6))))))
      (let* ((denom (/ (+ va vb vc))))
        (finish (v+ a (v* ab v) (v* ac w)) (* vb denom) (* vc denom))))))

(defun plane-box-overlap (normal vertex max-box)
  (let ((vmin (vec3)) (vmax (vec3)))
    (macrolet ((test (dim)
                 `(let ((v (,dim vertex)))
                    (if (< 0 (,dim normal))
                        (setf (,dim vmin) (- (- (,dim max-box)) v)
                              (,dim vmax) (- (,dim max-box) v))
                        (setf (,dim vmin) (- (,dim max-box) v)
                              (,dim vmax) (- (- (,dim max-box)) v))))))
      (test vx3)
      (test vy3)
      (test vz3))
    (and (not (< 0 (v. normal vmin)))
         (<= 0 (v. normal vmax)))))

(defun axis-test (a b fa fb v0 v1 v2 v3 box-half-size1 box-half-size2)
  (let* ((p0 (+ (* a v0) (* b v1)))
         (p1 (+ (* a v2) (* b v3)))
         (min (min p0 p1))
         (max (max p0 p1))
         (rad (+ (* fa box-half-size1) (* fb box-half-size2))))
    (not (or (< rad min) (< max (- rad))))))

(defun tri-box-overlap (box-center bsize tri0 tri1 tri2)
  ;; This is SAT.
  (let* ((v0 (v- tri0 box-center))
         (v1 (v- tri1 box-center))
         (v2 (v- tri2 box-center))
         (e0 (v- v1 v0))
         (e1 (v- v2 v1))
         (e2 (v- v0 v2))
         (fe0 (vabs e0))
         (fe1 (vabs e1))
         (fe2 (vabs e2)))
    (when (and (axis-test (vz e0) (- (vy e0)) (vz fe0) (vy fe0) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e0)) (vx e0) (vz fe0) (vx fe0) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e0) (- (vx e0)) (vy fe0) (vx fe0) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize))

               (axis-test (vz e1) (- (vy e1)) (vz fe1) (vy fe1) (vy v0) (vz v0) (vy v2) (vz v2) (vy bsize) (vz bsize))
               (axis-test (- (vz e1)) (vx e1) (vz fe1) (vx fe1) (vx v0) (vz v0) (vx v2) (vz v2) (vx bsize) (vz bsize))
               (axis-test (vy e1) (- (vx e1)) (vy fe1) (vx fe1) (vx v0) (vy v0) (vx v1) (vy v1) (vx bsize) (vz bsize))

               (axis-test (vz e2) (- (vy e2)) (vz fe2) (vy fe2) (vy v0) (vz v0) (vy v1) (vz v1) (vy bsize) (vz bsize))
               (axis-test (- (vz e2)) (vx e2) (vz fe2) (vx fe2) (vx v0) (vz v0) (vx v1) (vz v1) (vx bsize) (vz bsize))
               (axis-test (vy e2) (- (vx e2)) (vy fe2) (vx fe2) (vx v1) (vy v1) (vx v2) (vy v2) (vx bsize) (vy bsize)))
      (macrolet ((test (dim)
                   `(let ((min (min (,dim v0) (,dim v1) (,dim v2)))
                          (max (max (,dim v0) (,dim v1) (,dim v2))))
                      (not (or (< (,dim bsize) min) (< max (- (,dim bsize))))))))
        (when (and (test vx3) (test vy3) (test vz3))
          (plane-box-overlap (vc e0 e1) v0 bsize))))))

;;; Actual algorithm
(defun make-convex-hull (verts faces)
  (let ((volume (convex-volume verts faces)))
    (assert (<= 0 volume))
    (%make-convex-hull :vertices verts :faces faces
                       :center (centroid verts faces)
                       :volume (float volume 0d0))))

(defun combine-convex-hulls (a b)
  (multiple-value-bind (verts faces) 
      (org.shirakumo.fraf.quickhull:convex-hull
       (concatenate '(simple-array double-float (*))
                    (convex-hull-vertices a) (convex-hull-vertices b)))
    (make-convex-hull verts faces)))

(defun make-aabb-tree (vertices indices)
  (declare (type (simple-array double-float (*)) vertices))
  (declare (type (simple-array (unsigned-byte 32) (*)) indices))
  (declare (optimize speed (safety 1)))
  (let* ((max-faces-per-leaf 6)
         (num-faces (truncate (length indices) 3))
         (faces (make-array num-faces :element-type '(unsigned-byte 32)))
         (tree (%make-aabb-tree vertices indices faces))
         (nodes (aabb-tree-nodes tree))
         (depth 0))
    (declare (type (unsigned-byte 32) depth))
    (dotimes (i num-faces)
      (setf (aref faces i) i))
    (labels ((rec (node start end)
               (declare (type (unsigned-byte 32) start end))
               (let ((num-faces (- end start)))
                 (incf depth)
                 (setf (aabb-tree-depth tree) (max (aabb-tree-depth tree) depth))
                 (calculate-face-bounds tree start end node)
                 (cond ((<= num-faces max-faces-per-leaf)
                        (setf (aabb-node-faces node) (subseq faces start end))
                        (incf (aabb-tree-leaf-nodes tree)))
                       (T
                        (incf (aabb-tree-inner-nodes tree))
                        (let ((left-count (partition-median tree node faces start end))
                              (i0 (make-aabb-node))
                              (i1 (make-aabb-node)))
                          (declare (type (unsigned-byte 32) left-count))
                          (replace (aabb-node-children node) (list i0 i1))
                          (vector-push-extend i0 nodes)
                          (vector-push-extend i1 nodes)
                          (rec i0 start (+ start left-count))
                          (rec i1 (+ start left-count) end))))
                 (decf depth))))
      (vector-push-extend (make-aabb-node) nodes)
      (rec (aref nodes 0) 0 num-faces))
    tree))

(defun trace-ray (tree start dir)
  (let ((tt most-positive-double-float)
        u v w face-sign face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 1))
                             (dist-l (aabb-ray left start dir))
                             (dist-r (aabb-ray right start dir)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef dist-l dist-r))
                        (when (< dist-l tt)
                          (rec left))
                        (when (< dist-r tt)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (tt2 u2 v2 w2 s2) (ray-triangle start dir a b c)
                                 (when (< tt2 tt)
                                   (setf tt tt2 u u2 v v2 w w2 face-sign s2)
                                   (setf face-index (aref (aabb-node-faces node) i)))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (unless (= tt most-positive-double-float)
      (values tt u v w face-sign face-index))))

(defun closest-point-within-distance (tree point max-distance)
  (let ((distance max-distance)
        (sqr-distance (* max-distance max-distance))
        p v w face-index)
    (labels ((rec (node)
               (cond ((= 0 (length (aabb-node-faces node)))
                      (let* ((left (aref (aabb-node-children node) 0))
                             (right (aref (aabb-node-children node) 1))
                             (lp (aabb-closest-point left point))
                             (rp (aabb-closest-point right point))
                             (dist-l (vsqrdistance point lp))
                             (dist-r (vsqrdistance point rp)))
                        (when (< dist-r dist-l)
                          (rotatef left right)
                          (rotatef lp rp)
                          (rotatef dist-l dist-r))
                        (when (< dist-l sqr-distance)
                          (rec left))
                        (when (< dist-r sqr-distance)
                          (rec right))))
                     (T
                      (loop for i from 0
                            for face across (aabb-node-faces node)
                            for base-vertex = (* 3 (aref (aabb-tree-indices tree) face))
                            for a = (v (aabb-tree-vertices tree) (+ base-vertex 0))
                            for b = (v (aabb-tree-vertices tree) (+ base-vertex 1))
                            for c = (v (aabb-tree-vertices tree) (+ base-vertex 2))
                            do (multiple-value-bind (cp v2 w2) (closest-point-on-triangle* a b c point)
                                 (let ((sqr-distance2 (vsqrdistance cp point)))
                                   (when (< sqr-distance2 sqr-distance)
                                     (setf p cp sqr-distance sqr-distance2 v v2 w w2)
                                     (setf face-index (aref (aabb-node-faces node) i))))))))))
      (rec (aref (aabb-tree-nodes tree) 0)))
    (when p
      (values p distance v w face-index))))

(defun calculate-face-bounds (tree start end &optional (aabb (make-aabb)))
  (flet ((update (p)
           (setf (aabb-min aabb) (vmin (aabb-min aabb) p))
           (setf (aabb-max aabb) (vmax (aabb-max aabb) p))))
    (loop for face from start below end
          for index = (aref (aabb-tree-indices tree) face)
          do (update (v (aabb-tree-vertices tree) index)))
    aabb))

(defun partition-median (tree node faces start end)
  (declare (optimize speed (safety 0)))
  (let ((axis (aabb-longest-axis node))
        (verts (aabb-tree-vertices tree))
        (indices (aabb-tree-indices tree)))
    (labels ((centroid (face)
               (declare (type (unsigned-byte 32) face))
               (let* ((index (* 3 face))
                      (a (aref verts (+ axis (* 3 (aref indices (+ 0 index))))))
                      (b (aref verts (+ axis (* 3 (aref indices (+ 1 index))))))
                      (c (aref verts (+ axis (* 3 (aref indices (+ 2 index)))))))
                 (/ (+ a b c) 3.0)))
             (compare (lhs rhs)
               (declare (optimize speed))
               (let ((a (centroid lhs))
                     (b (centroid rhs)))
                 (if (= a b)
                     (< lhs rhs)
                     (< a b)))))
      (declare (dynamic-extent #'centroid #'compare))
      ;; KLUDGE: This SUUUUUCKS
      #-sbcl
      (let ((sub (make-array (- end start)
                             :element-type (array-element-type faces)
                             :displaced-to faces
                             :displaced-index-offset start)))
        (replace faces (sort sub #'compare) :start1 start))
      #+sbcl
      (sb-impl::with-array-data ((vector (the vector faces))
                                 (start start)
                                 (end end)
                                 :check-fill-pointer T)
        (sb-impl::sort-vector vector start end #'compare NIL))
      (truncate (- end start) 2))))

(declaim (inline voxel-value))
(defun voxel-value (v)
  (ecase v
    (0 :undefined)
    (1 :outside-surface-to-walk)
    (2 :outside-surface)
    (3 :inside-surface)
    (4 :on-surface)
    (:undefined 0)
    (:outside-surface-to-walk 1)
    (:outside-surface 2)
    (:inside-surface 3)
    (:on-surface 4)))

(defmacro with-voxel-walk ((i &optional i0 i1) (j &optional j0 j1) (k &optional k0 k1) &body body)
  `(macrolet ((voxel-idx (x y z)
                `(+ ,x (* (aref dims 0) (+ ,y (* (aref dims 1) ,z)))))
              (voxel (x y z)
                `(aref data (voxel-idx ,x ,y ,z))))
     (loop for ,i from ,(or i0 0) below ,(or i1 '(aref dims 0))
           do (loop for ,j from ,(or j0 0) below ,(or j1 '(aref dims 1))
                    do (loop for ,k from ,(or k0 0) below ,(or k1 '(aref dims 2))
                             do ,@body)))))

(defun make-volume (points indices dimensions)
  (when (< 0 (length points))
    (let* ((dim (max 32 (truncate (* (expt dimensions 0.33) 1.5))))
           (bounds (aabb-bounds points))
           (d (aabb-size bounds))
           (dims (make-array 3 :element-type '(unsigned-byte 32)))
           (r 0.0d0))
      (cond ((and (<= (vy d) (vx d)) (<= (vz d) (vx d)))
             (replace dims (list dim
                                 (+ 2 (truncate (* dim (vy d)) (vx d)))
                                 (+ 2 (truncate (* dim (vz d)) (vx d)))))
             (setf r (f64* (vx d))))
            ((and (<= (vx d) (vy d)) (<= (vz d) (vx d)))
             (replace dims (list dim
                                 (+ 2 (truncate (* dim (vx d)) (vy d)))
                                 (+ 2 (truncate (* dim (vz d)) (vy d)))))
             (setf r (f64* (vy d))))
            (T
             (replace dims (list dim
                                 (+ 2 (truncate (* dim (vx d)) (vz d)))
                                 (+ 2 (truncate (* dim (vy d)) (vz d)))))
             (setf r (f64* (vz d)))))
      (let* ((scale (/ r (1- dim)))
             (inv-scale (/ (1- dim) r))
             (data (make-array (* (aref dims 0) (aref dims 1) (aref dims 2)) 
                               :element-type '(unsigned-byte 8) :initial-element 0))
             (volume (%make-volume :min (aabb-min bounds) :max (aabb-max bounds)
                                   :scale scale :dimensions dims :data data))
             (p (map-into (make-array 3) #'vec3)))
        (loop for base-index from 0 below (length indices) by 3
              for i0 = 0 for j0 = 0 for k0 = 0
              for i1 = 0 for j1 = 0 for k1 = 0
              do (loop for c from 0 below 3
                       for pt = (v points (aref indices (+ base-index c)))
                       do (setf (aref p c) (nv* (v- pt (aabb-min bounds)) inv-scale))
                          (let ((i (truncate (+ 0.5 (vx (aref p c)))))
                                (j (truncate (+ 0.5 (vy (aref p c)))))
                                (k (truncate (+ 0.5 (vz (aref p c))))))
                            (assert (and (< i (aref dims 0)) (< j (aref dims 1)) (< k (aref dims 2))))
                            (cond ((= 0 c)
                                   (setf i0 i i1 i)
                                   (setf j0 j j1 j)
                                   (setf k0 k k1 k))
                                  (T
                                   (setf i0 (min i0 i) i1 (max i1 i))
                                   (setf j0 (min j0 j) j1 (max j1 j))
                                   (setf k0 (min k0 k) k1 (max k1 k))))))
                 (when (< 0 i0) (decf i0))
                 (when (< 0 j0) (decf j0))
                 (when (< 0 k0) (decf k0))
                 (when (< i1 (aref dims 0)) (incf i1))
                 (when (< j1 (aref dims 1)) (incf j1))
                 (when (< k1 (aref dims 2)) (incf k1))
                 (with-voxel-walk (i i0 i1) (j j0 j1) (k k0 k1)
                   (when (and (= 0 (voxel i j k))
                              (tri-box-overlap (vec i j k) (vec 0.5 0.5 0.5) (aref p 0) (aref p 1) (aref p 2)))
                     (setf (voxel i j k) (voxel-value :on-surface))
                     (incf (volume-voxels-on-surface volume))
                     (vector-push-extend (make-voxel i j k) (volume-surface-voxels volume)))))
        ;; Mark voxels along volume borders as outside
        (mark-outside-surface volume 0 0 0 (aref dims 0) (aref dims 1) 1)
        (mark-outside-surface volume 0 0 (1- (aref dims 2)) (aref dims 0) (aref dims 1) (aref dims 2))
        (mark-outside-surface volume 0 0 0 (aref dims 0) 1 (aref dims 2))
        (mark-outside-surface volume 0 (1- (aref dims 1)) 0 (aref dims 0) (aref dims 1) (aref dims 2))
        (mark-outside-surface volume 0 0 0 1 (aref dims 1) (aref dims 2))
        (mark-outside-surface volume (1- (aref dims 0)) 0 0 (aref dims 0) (aref dims 1) (aref dims 2))
        ;; Flood fill up to surface voxels
        (fill-outside-surface volume)
        ;; Anything not filled now must be an inside voxel
        (fill-inside-surface volume)))))

(defun mark-outside-surface (volume i0 j0 k0 i1 j1 k1)
  (let ((data (volume-data volume))
        (dims (volume-dimensions volume)))
    (with-voxel-walk (i i0 i1) (j j0 j1) (k k0 k1)
      (when (= 0 (voxel i j k))
        (setf (voxel i j k) (voxel-value :outside-surface-to-walk))))))

(defun walk-forward (data data-i start end stride max-distance)
  (loop for i from start below end
        for count from 0 below max-distance
        while (= 0 (aref data data-i))
        do (setf (aref data data-i) (voxel-value :outside-surface-to-walk))
           (incf data-i stride))
  data-i)

(defun walk-backward (data data-i start end stride max-distance)
  (loop for i downfrom start to end
        for count from 0 below max-distance
        while (= 0 (aref data data-i))
        do (setf (aref data data-i) (voxel-value :outside-surface-to-walk))
           (decf data-i stride))
  data-i)

(defun fill-outside-surface (volume)
  (let* ((voxels-walked 0)
         (dims (volume-dimensions volume))
         (data (volume-data volume))
         (i1 (aref dims 0))
         (j1 (aref dims 1))
         (k1 (aref dims 2))
         (walk-distance 64)
         ;; The original code here is bonkers.
         (istride 1)
         (jstride i1)
         (kstride (* i1 j1)))
    (loop do (setf voxels-walked 0)
             (with-voxel-walk (i) (j) (k)
               (when (= (voxel i j k) (voxel-value :outside-surface-to-walk))
                 (incf voxels-walked)
                 (setf (voxel i j k) (voxel-value :outside-surface))
                 
                 (walk-forward data (+ (voxel-idx i j k) kstride) (1+ k) k1 kstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) kstride) (1- k) 0 kstride walk-distance)

                 (walk-forward data (+ (voxel-idx i j k) jstride) (1+ j) j1 jstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) jstride) (1- j) 0 jstride walk-distance)

                 (walk-forward data (+ (voxel-idx i j k) istride) (1+ i) i1 kstride walk-distance)
                 (walk-backward data (- (voxel-idx i j k) istride) (1- i) 0 istride walk-distance)))
             (incf (volume-voxels-outside-surface volume) voxels-walked)
          while (/= 0 voxels-walked))
    volume))

(defun fill-inside-surface (volume)
  (let* ((dims (volume-dimensions volume))
         (data (volume-data volume)))
    (setf (fill-pointer (volume-interior-voxels volume)) 0)
    (with-voxel-walk (i) (j) (k)
      (when (= 0 (voxel i j k))
        (setf (voxel i j k) (voxel-value :inside-surface))
        (vector-push-extend (make-voxel i j k) (volume-interior-voxels volume))
        (incf (volume-voxels-inside-surface volume))))
    volume))

(defun shrink-wrap (verts aabb-tree max-hull-vertex-count distance-threshold shrinkrap-p)
  (when shrinkrap-p
    (loop for j from 0 below (truncate (length verts) 3)
          for p = (v verts j)
          for closest = (closest-point-within-distance aabb-tree p distance-threshold)
          do (when closest
               (setf (aref verts j) closest))))
  (org.shirakumo.fraf.quickhull:convex-hull verts :max-vertex-count max-hull-vertex-count))

(defun make-voxel-hull (parent axis split-loc)
  (let* ((volume (aref (voxel-hull-voxels parent) 0))
         (hull (%make-voxel-hull :min (aabb-min parent)
                                 :max (aabb-max parent)
                                 :axis axis
                                 :voxels (voxel-hull-voxels parent)
                                 :voxel-scale (volume-scale volume)
                                 :voxel-adjust (v- (aabb-min volume) (* 0.5 (volume-scale volume)))
                                 :depth (1+ (voxel-hull-depth parent))
                                 :m1 (copy-seq (voxel-hull-m1 parent))
                                 :m2 (copy-seq (voxel-hull-m2 parent))
                                 :decomposer (voxel-hull-decomposer parent))))
    (ecase axis
      (:x- (setf (aref (voxel-hull-m2 hull) 0) split-loc))
      (:x+ (setf (aref (voxel-hull-m1 hull) 0) (1+ split-loc)))
      (:y- (setf (aref (voxel-hull-m2 hull) 1) split-loc))
      (:y+ (setf (aref (voxel-hull-m1 hull) 1) (1+ split-loc)))
      (:z- (setf (aref (voxel-hull-m2 hull) 2) split-loc))
      (:z+ (setf (aref (voxel-hull-m1 hull) 2) (1+ split-loc))))
    ;; Copy all intersecting interior voxels
    (loop for v across (voxel-hull-interior-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (if (ecase axis
                     (:x- (= (aref va 0) split-loc))
                     (:x+ (= (aref va 0) (aref (voxel-hull-m1 hull) 0)))
                     (:y- (= (aref va 1) split-loc))
                     (:y+ (= (aref va 1) (aref (voxel-hull-m1 hull) 1)))
                     (:z- (= (aref va 2) split-loc))
                     (:z+ (= (aref va 2) (aref (voxel-hull-m1 hull) 2))))
                   (vector-push-extend v (voxel-hull-surface-voxels hull))
                   (vector-push-extend v (voxel-hull-interior-voxels hull)))))
    ;; Copy all intersecting surface voxels
    (loop for v across (voxel-hull-surface-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (vector-push-extend v (voxel-hull-surface-voxels hull))))
    (loop for v across (voxel-hull-new-surface-voxels parent)
          for va = (voxel-array v)
          do (when (and (every #'<= (voxel-hull-m1 hull) va)
                        (every #'<= va (voxel-hull-m2 hull)))
               (vector-push-extend v (voxel-hull-new-surface-voxels hull))))
    ;; Recompute the bounding box
    (fill (voxel-hull-m1 hull) #x7FFFFFFF)
    (fill (voxel-hull-m2 hull) 0)
    (loop for v across (voxel-hull-surface-voxels hull) do (min-max-voxel-region hull v))
    (loop for v across (voxel-hull-new-surface-voxels hull) do (min-max-voxel-region hull v))
    (loop for v across (voxel-hull-interior-voxels hull) do (min-max-voxel-region hull v))
    ;; Rebuild
    (build-voxel-mesh hull)
    (build-raycast-mesh hull)
    (compute-convex-hull hull)))

(defun make-voxel-hull* (volume decomposer)
  (let* ((hull (%make-voxel-hull :min (aabb-min volume)
                                 :max (aabb-max volume)
                                 :voxels (vector volume)
                                 :voxel-scale (volume-scale volume)
                                 :voxel-adjust (v- (aabb-min volume) (* 0.5 (volume-scale volume)))
                                 :surface-voxels (copy-seq (volume-surface-voxels volume))
                                 :interior-voxels (copy-seq (volume-interior-voxels volume))
                                 :m2 (map '(simple-array (unsigned-byte 32) (3)) #'1- (volume-dimensions volume))
                                 :decomposer decomposer)))
    (build-voxel-mesh hull)
    (build-raycast-mesh hull)
    (compute-convex-hull hull)))

(defun min-max-voxel-region (hull v)
  (map-into (voxel-hull-m1 hull) #'min (voxel-hull-m1 hull) (voxel-array v))
  (map-into (voxel-hull-m2 hull) #'max (voxel-hull-m2 hull) (voxel-array v))
  hull)

(defun build-voxel-mesh (hull)
  (loop for v across (voxel-hull-surface-voxels hull)
        do (add-voxel-box hull v))
  (loop for v across (voxel-hull-new-surface-voxels hull)
        do (add-voxel-box hull v)))

(defun build-raycast-mesh (hull)
  (when (/= 0 (length (voxel-hull-indices hull)))
    (setf (voxel-hull-aabb-tree hull) (make-aabb-tree (ensure-f64 (voxel-hull-vertices hull))
                                                      (ensure-u32 (voxel-hull-indices hull)))))
  hull)

(defun compute-convex-hull (hull)
  (when (/= 0 (length (voxel-hull-vertices hull)))
    (multiple-value-bind (verts faces) (org.shirakumo.fraf.quickhull:convex-hull (voxel-hull-vertices hull))
      (setf (voxel-hull-convex-hull hull) (make-convex-hull verts faces))))
  (when (voxel-hull-convex-hull hull)
    (setf (voxel-hull-volume hull) (convex-hull-volume (voxel-hull-convex-hull hull))))
  (let ((single-voxel-volume (expt (voxel-hull-voxel-scale hull) 3))
        (voxel-count (+ (length (voxel-hull-interior-voxels hull))
                        (length (voxel-hull-surface-voxels hull))
                        (length (voxel-hull-new-surface-voxels hull)))))
    (setf (voxel-hull-voxel-volume hull) (* voxel-count single-voxel-volume))
    (setf (voxel-hull-volume-error hull) (/ (* (abs (- (voxel-hull-volume hull) (voxel-hull-voxel-volume hull)))
                                               100)
                                            (voxel-hull-voxel-volume hull)))
    hull))

(defun voxel-hull-complete-p (hull)
  (or (null (voxel-hull-convex-hull hull))
      (< (voxel-hull-volume-error hull)
         (decomposer-error-percentage (voxel-hull-decomposer hull)))
      (< (decomposer-max-recursion-depth (voxel-hull-decomposer hull)) (voxel-hull-depth hull))
      (every (lambda (m2 m1) (<= (- m2 m1) (decomposer-minimum-edge-length (voxel-hull-decomposer hull))))
             (voxel-hull-m2 hull) (voxel-hull-m1 hull))))

(defun voxel-hull-point (v hull)
  (declare (optimize speed))
  (declare (type voxel v))
  (let ((scale (voxel-hull-voxel-scale hull))
        (bmin (voxel-hull-voxel-adjust hull)))
    (vec (+ (* (voxel-x v) scale) (vx bmin))
         (+ (* (voxel-y v) scale) (vy bmin))
         (+ (* (voxel-z v) scale) (vz bmin)))))

(defun voxel-index (hull v)
  (declare (optimize speed))
  (declare (type voxel v))
  (or (gethash v (voxel-hull-voxel-index-map hull))
      (let ((p (voxel-hull-point v hull))
            (i (hash-table-count (voxel-hull-voxel-index-map hull))))
        (setf (gethash v (voxel-hull-voxel-index-map hull)) i)
        (vector-push-extend (f64* (vx p)) (voxel-hull-vertices hull))
        (vector-push-extend (f64* (vy p)) (voxel-hull-vertices hull))
        (vector-push-extend (f64* (vz p)) (voxel-hull-vertices hull))
        i)))

(defun add-voxel-box (hull v)
  (macrolet ((bmin (dim)
               `(+ 0 (,(intern (format NIL "~a-~a" 'voxel dim)) v)))
             (bmax (dim)
               `(+ 1 (,(intern (format NIL "~a-~a" 'voxel dim)) v))))
    (let ((p0 (make-voxel (bmin x) (bmin y) (bmin z)))
          (p1 (make-voxel (bmax x) (bmin y) (bmin z)))
          (p2 (make-voxel (bmax x) (bmax y) (bmin z)))
          (p3 (make-voxel (bmin x) (bmax y) (bmin z)))
          (p4 (make-voxel (bmin x) (bmin y) (bmax z)))
          (p5 (make-voxel (bmax x) (bmin y) (bmax z)))
          (p6 (make-voxel (bmax x) (bmax y) (bmax z)))
          (p7 (make-voxel (bmin x) (bmax y) (bmax z))))
      (add-triangle hull p2 p1 p0)
      (add-triangle hull p3 p2 p0)

      (add-triangle hull p7 p2 p3)
      (add-triangle hull p7 p6 p2)

      (add-triangle hull p5 p1 p2)
      (add-triangle hull p5 p2 p6)

      (add-triangle hull p5 p4 p1)
      (add-triangle hull p4 p0 p1)

      (add-triangle hull p4 p6 p7)
      (add-triangle hull p4 p5 p6)

      (add-triangle hull p4 p7 p0)
      (add-triangle hull p7 p3 p0))))

(defun add-triangle (hull p1 p2 p3)
  (vector-push-extend (voxel-index hull p1) (voxel-hull-indices hull))
  (vector-push-extend (voxel-index hull p2) (voxel-hull-indices hull))
  (vector-push-extend (voxel-index hull p3) (voxel-hull-indices hull)))

(defun compute-split-plane (hull)
  (let ((d (map 'vector #'- (voxel-hull-m2 hull) (voxel-hull-m1 hull))))
    (cond ((and (<= (aref d 1) (aref d 0)) (<= (aref d 2) (aref d 0)))
           (values :x
                   (truncate (+ 1 (aref (voxel-hull-m2 hull) 0) (aref (voxel-hull-m1 hull) 0)) 2)))
          ((and (<= (aref d 0) (aref d 1)) (<= (aref d 2) (aref d 1)))
           (values :y
                   (truncate (+ 1 (aref (voxel-hull-m2 hull) 1) (aref (voxel-hull-m1 hull) 1)) 2)))
          (T
           (values :z
                   (truncate (+ 1 (aref (voxel-hull-m2 hull) 2) (aref (voxel-hull-m1 hull) 2)) 2))))))

(defun raycast (hull p1 p2)
  (let* ((from (voxel-hull-point hull p1))
         (dir (nvunit (v- (voxel-hull-point hull p2) from))))
    (or (trace-ray (voxel-hull-aabb-tree hull) from dir) 0.0d0)))

;; Omit find-concavity

(defun perform-plane-split (hull)
  (unless (voxel-hull-complete-p hull)
    (multiple-value-bind (axis split-location) (compute-split-plane hull)
      (ecase axis
        (:x
         (setf (voxel-hull-a hull) (make-voxel-hull hull :x- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :x+ split-location)))
        (:y
         (setf (voxel-hull-a hull) (make-voxel-hull hull :y- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :y+ split-location)))
        (:z
         (setf (voxel-hull-a hull) (make-voxel-hull hull :z- split-location))
         (setf (voxel-hull-b hull) (make-voxel-hull hull :z+ split-location))))))
  hull)

(defun reduce-convex-hull (decomposer ch &key (max-vertices (decomposer-max-vertices-per-convex-hull decomposer))
                                              (shrink-wrap-p (decomposer-shrink-wrap-p decomposer)))
  (multiple-value-bind (verts faces)
      (shrink-wrap (convex-hull-vertices ch)
                   (decomposer-aabb-tree decomposer)
                   max-vertices (* 4 (decomposer-voxel-scale decomposer))
                   shrink-wrap-p)
    (make-convex-hull verts faces)))

(defun compute-concavity (volume-separate volume-combined volume-mesh)
  (/ (abs (- volume-separate volume-combined)) volume-mesh))

(defun perform-task (decomposer task)
  (let* ((a (cost-task-a task))
         (b (cost-task-b task))
         (va (convex-hull-volume a))
         (vb (convex-hull-volume b))
         (combined (combine-convex-hulls a b))
         (combined-volume (convex-hull-volume combined)))
    (setf (cost-task-concavity task) (compute-concavity (+ va vb) combined-volume (decomposer-overall-hull-volume decomposer)))))

(defun fast-cost (decomposer task)
  (let ((a (cost-task-a task))
        (b (cost-task-b task)))
    (unless (aabb-intersects-p a b)
      (let ((concavity (compute-concavity (+ (convex-hull-volume a) (convex-hull-volume a))
                                          (aabb-volume (aabb-union a b))
                                          (decomposer-overall-hull-volume decomposer))))
        (priority-queue:pqueue-push (make-hull-pair a b concavity) concavity
                                    (decomposer-hull-pair-queue decomposer))))))

(defun add-cost (decomposer task)
  (priority-queue:pqueue-push (make-hull-pair (cost-task-a task) (cost-task-b task) (cost-task-concavity task))
                              (cost-task-concavity task)
                              (decomposer-hull-pair-queue decomposer)))

(defun scale-convex-hull (decomposer hull)
  (let ((verts (convex-hull-vertices hull))
        (faces (convex-hull-faces hull))
        (scale (decomposer-scale decomposer))
        (center (decomposer-center decomposer)))
    (loop for v from 0 below (length verts) by 3
          do (setf (aref verts (+ 0 v)) (+ (vx center) (* scale (aref verts (+ 0 v)))))
             (setf (aref verts (+ 1 v)) (+ (vy center) (* scale (aref verts (+ 1 v)))))
             (setf (aref verts (+ 2 v)) (+ (vz center) (* scale (aref verts (+ 2 v))))))
    (let ((volume (convex-volume verts faces)))
      (assert (<= 0 volume))
      (setf (convex-hull-volume hull) volume))
    (setf (convex-hull-center hull) (centroid verts faces))
    hull))

(defun %decompose (decomposer vertices indices)
  ;; Prepare the necessary data
  (let* ((pending (make-array 0 :adjustable T :fill-pointer T))
         (voxel-hulls (make-array 0 :adjustable T :fill-pointer T))
         (hulls (make-array 0 :adjustable T :fill-pointer T))
         (bounds (aabb-bounds vertices))
         (center (aabb-center bounds)))
    (setf (decomposer-center decomposer) center)
    (setf (decomposer-scale decomposer) (f64* (vmaxcoeff (v- (aabb-max bounds) (aabb-min bounds)))))
    (setf (decomposer-recip-scale decomposer) (if (= 0 (decomposer-scale decomposer))
                                                  0.0d0
                                                  (decomposer-scale decomposer)))
    (dbg "Normalizing mesh")
    (multiple-value-bind (vertices indices) (normalize vertices indices :center center :scale (decomposer-scale decomposer))
      (dbg "Computing aabb tree")
      (setf (decomposer-aabb-tree decomposer) (make-aabb-tree vertices indices))
      (dbg "Computing initial voxel volume")
      (setf (decomposer-voxelize decomposer) (make-volume vertices indices (decomposer-resolution decomposer)))
      (setf (decomposer-voxel-scale decomposer) (volume-scale (decomposer-voxelize decomposer))))
    (dbg "Voxelizing volume")
    (let ((vh (make-voxel-hull* (decomposer-voxelize decomposer) decomposer)))
      (when (voxel-hull-convex-hull vh)
        (setf (decomposer-overall-hull-volume decomposer)
              (convex-hull-volume (voxel-hull-convex-hull vh))))
      (vector-push-extend vh pending)
      ;; Split hulls as much as possible
      (dbg "Splitting voxel hulls")
      (loop while (< 0 (length pending))
            do (let ((count (+ (length pending) (length voxel-hulls)))
                     (old (shiftf pending (make-array 0 :adjustable T :fill-pointer T))))
                 (loop for hull across old
                       do (when (and (not (voxel-hull-complete-p hull))
                                     (< count (decomposer-max-convex-hull-fragments decomposer)))
                            (perform-plane-split hull)))
                 (loop for hull across old
                       do (cond ((or (voxel-hull-complete-p hull)
                                     (< (decomposer-max-convex-hull-fragments decomposer) count))
                                 (when (voxel-hull-convex-hull hull)
                                   (vector-push-extend hull voxel-hulls)))
                                (T
                                 (when (voxel-hull-a hull)
                                   (vector-push-extend (voxel-hull-a hull) pending))
                                 (when (voxel-hull-b hull)
                                   (vector-push-extend (voxel-hull-b hull) pending))))))))
    ;; Build the convex hulls from the voxel hulls
    (dbg "Building convex hulls")
    (loop for hull across voxel-hulls
          do (vector-push-extend (voxel-hull-convex-hull hull) hulls))
    ;; Merge convex hulls down as much as needed
    (let ((hull-count (length hulls)))
      (when (< (decomposer-convex-hulls decomposer) hull-count)
        (dbg "Merging convex hulls")
        (let ((tasks (make-array 0 :adjustable T :fill-pointer T)))
          ;; Compute the costs and init our priority queue
          (loop for i from 1 below hull-count
                for ch-a = (aref hulls i)
                do (loop for j from 0 below i
                         for ch-b = (aref hulls j)
                         for task = (make-cost-task ch-a ch-b)
                         do (unless (fast-cost decomposer task)
                              (vector-push-extend task tasks))))
          (loop for task across tasks
                do (perform-task decomposer task)
                   (add-cost decomposer task)))
        ;; Actually merge convex hulls now
        (loop until (or (priority-queue:pqueue-empty-p (decomposer-hull-pair-queue decomposer))
                        (<= (decomposer-convex-hulls decomposer) (length hulls)))
              do (let* ((pair (priority-queue:pqueue-pop (decomposer-hull-pair-queue decomposer)))
                        (ch-a (hull-pair-a pair))
                        (ch-b (hull-pair-b pair)))
                   (when (and ch-a ch-b)
                     (let ((combined (combine-convex-hulls ch-a ch-b))
                           (tasks (make-array 0 :adjustable T :fill-pointer T)))
                       (loop for hull across hulls
                             for task = (make-cost-task combined hull)
                             do (unless (fast-cost decomposer task)
                                  (vector-push-extend task tasks)))
                       (vector-push-extend combined hulls)
                       (loop for task across tasks
                             do (perform-task decomposer task))
                       (loop for task across tasks
                             do (add-cost decomposer task))))))))
    ;; Finalize by reducing hulls if necessary and scaling them
    (dbg "Reducing convex hulls")
    (loop for i from 0 below (length hulls)
          for hull = (aref hulls i)
          do (when (or (< (decomposer-max-vertices-per-convex-hull decomposer)
                          (truncate (length (convex-hull-vertices hull)) 3))
                       (decomposer-shrink-wrap-p decomposer))
               (setf (aref hulls i) (setf hull (reduce-convex-hull decomposer hull))))
             (scale-convex-hull decomposer hull))
    hulls))

(defun decompose (verts faces &rest args &key convex-hulls
                                              resolution
                                              error-percentage
                                              max-recursion-depth
                                              max-convex-hull-fragments
                                              shrink-wrap-p
                                              max-vertices-per-convex-hull
                                              minimum-edge-length)
  (declare (ignore convex-hulls resolution error-percentage max-recursion-depth
                   max-convex-hull-fragments
                   shrink-wrap-p max-vertices-per-convex-hull minimum-edge-length))
  (let ((*dbg-start-time* (get-internal-real-time)))
    (%decompose (apply #'make-decomposer args) verts faces)))
